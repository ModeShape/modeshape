<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ JBoss DNA (http://www.jboss.org/dna)
  ~
  ~ See the COPYRIGHT.txt file distributed with this work for information
  ~ regarding copyright ownership.  Some portions may be licensed
  ~ to Red Hat, Inc. under one or more contributor license agreements.
  ~ See the AUTHORS.txt file in the distribution for a full listing of 
  ~ individual contributors.
  ~
  ~ JBoss DNA is free software. Unless otherwise indicated, all code in JBoss DNA
  ~ is licensed to you under the terms of the GNU Lesser General Public License as
  ~ published by the Free Software Foundation; either version 2.1 of
  ~ the License, or (at your option) any later version.
  ~
  ~ JBoss DNA is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="custom_sequencers">
  <title>Creating custom sequencers</title>
  <para>The current release of JBoss DNA comes with six sequencers.  However, it's very easy to create your own
  sequencers and to then configure JBoss DNA to use them in your own application.
  </para>
  <para>
  Creating a custom sequencer involves the following steps:
  <itemizedlist>
    <listitem>
      <para>Create a Maven 2 project for your sequencer;</para>
    </listitem>
    <listitem>
      <para>Implement the <code>org.jboss.dna.spi.sequencers.StreamSequencer</code> interface with your own implementation, and create unit tests to verify
      the functionality and expected behavior;</para>
    </listitem>
    <listitem>
      <para>Add the sequencer configuration to the JBoss DNA <code>SequencingService</code> in your application
      as described in the <link linkend="using_dna">previous chapter</link>; and</para>
    </listitem>
    <listitem>
      <para>Deploy the JAR file with your implementation (as well as any dependencies), and make them available to JBoss DNA
      in your application.</para>
    </listitem>
  </itemizedlist>
  It's that simple.
  </para>
  <sect1 id="custom_sequencer_project">
    <title>Creating the Maven 2 project</title>
    <para>The first step is to create the Maven 2 project that you can use to compile your code and build the JARs.
    Maven 2 automates a lot of the work, and since you're already <link linkend="downloading_and_running">set up to use Maven</link>,
    using Maven for your project will save you a lot of time and effort.  Of course, you don't have to use Maven 2, but then you'll
    have to get the required libraries and manage the compiling and building process yourself.</para>
    <note>
      <para>JBoss DNA may provide in the future a Maven archetype for creating sequencer projects.  If you'd find this useful
        and would like to help create it, please <link linkend="preface">join the community</link>.</para>
    </note>
  <note>
    <para>The <code>dna-sequencer-images</code> project is a small, self-contained sequencer implementation that
    has only the minimal dependencies.  Starting with this project's source and modifying it to suit your needs may be the easiest way to get started.
    See the subversion repository: <ulink url="http://anonsvn.jboss.org/repos/dna/trunk/extensions/dna-sequencer-images/">http://anonsvn.jboss.org/repos/dna/trunk/sequencers/dna-sequencer-images/</ulink>
    </para>
  </note>
    <para>You can create your Maven project any way you'd like.  For examples, see the <ulink url="http://maven.apache.org/guides/getting-started/index.html#How_do_I_make_my_first_Maven_project">Maven 2 documentation</ulink>.  
    Once you've done that, just add the dependencies in your project's <code>pom.xml</code> dependencies section:</para>
  	<programlisting role="XML"><![CDATA[
<dependency>
  <groupId>org.jboss.dna</groupId>
  <artifactId>dna-common</artifactId>
  <version>0.5</version>
</dependency>
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-api</artifactId>
</dependency>
 ]]></programlisting>
		<para>These are minimum dependencies required for compiling a sequencer.  Of course, you'll have to add
  		other dependencies that your sequencer needs.</para>
  	<para>As for testing, you probably will want to add more dependencies, such as those listed here:</para>
		<programlisting role="XML"><![CDATA[
<dependency>
  <groupId>junit</groupId>
  <artifactId>junit</artifactId>
  <version>4.4</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.hamcrest</groupId>
  <artifactId>hamcrest-library</artifactId>
  <version>1.1</version>
  <scope>test</scope>
</dependency>
<!-- Logging with Log4J -->
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-log4j12</artifactId>
  <version>1.4.3</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>log4j</groupId>
  <artifactId>log4j</artifactId>
  <version>1.2.14</version>
  <scope>test</scope>
</dependency>
 ]]></programlisting>
  	<para>Testing JBoss DNA sequencers does not require a JCR repository or the JBoss DNA services.  (For more detail,
  		see the <link linkend="testing_custom_sequencers">testing section</link>.)  However, if you want to do
  		integration testing with a JCR repository and the JBoss DNA services, you'll need additional dependencies for these libraries.</para>
		<programlisting role="XML"><![CDATA[
<!-- JBoss DNA JCR Repository -->
<dependency>
  <groupId>org.jboss.dna</groupId>
  <artifactId>dna-jcr</artifactId>
  <version>0.5</version>
  <scope>test</scope>
</dependency>
<!-- Java Content Repository API -->
<dependency>
  <groupId>javax.jcr</groupId>
  <artifactId>jcr</artifactId>
  <version>1.0.1</version>
  <scope>test</scope>
</dependency>
 ]]></programlisting>
  <para>At this point, your project should be set up correctly, and you're ready to move on to 
  	<link linkend="custom_sequencer_implementation">writing the Java implementation</link> for your sequencer.</para>
  </sect1>
  <sect1 id="custom_sequencer_implementation">
    <title>Implementing the StreamSequencer interface</title>
    <para>After creating the project and setting up the dependencies, the next step is to create a Java class that implements
    	the <code>org.jboss.dna.spi.sequencers.StreamSequencer</code> interface.  This interface is very straightforward
    	and involves a single method:</para>
    <programlisting role="JAVA"><![CDATA[
public interface StreamSequencer {

    /**
     * Sequence the data found in the supplied stream, placing the output 
     * information into the supplied map.
     *
     * @param stream the stream with the data to be sequenced; never null
     * @param output the output from the sequencing operation; never null
     * @param context the context for the sequencing operation; never null
     */
    void sequence( InputStream stream, SequencerOutput output, SequencerContext context );
 ]]></programlisting>
    <para>The job of a stream sequencer is to process the data in the supplied stream, and place into the <code>SequencerOutput</code> 
    any information that is to go into the JCR repository.  JBoss DNA figures out when your sequencer should be called
    (of course, using the sequencing configuration you'll add in a bit), and then makes sure the generated information
    is saved in the correct place in the repository.  
    </para>
    <para>The <code>SequencerContext</code> provides information about
    the current sequencing operation, including the location and properties of the node being sequenced, the MIME type
    of the node being sequenced, and a location to record problems that aren't severe enough to warrant throwing an exception.
    </para>
    <para>The <code>SequencerOutput</code> class is fairly easy to use.  There are basically two methods you need to call.
    One method sets the property values, while the other sets references to other nodes in the repository.  Use these
    methods to describe the properties of the nodes you want to create, using relative paths for the nodes and
    valid JCR property names for properties and references.  JBoss DNA will ensure that nodes are created or updated
    whenever they're needed.</para>
    <programlisting role="JAVA"><![CDATA[
public interface SequencerOutput {

  /**
   * Set the supplied property on the supplied node.  The allowable
   * values are any of the following:
   *   - primitives (which will be autoboxed)
   *   - String instances
   *   - String arrays
   *   - byte arrays
   *   - InputStream instances
   *   - Calendar instances
   *
   * @param nodePath the path to the node containing the property; 
   * may not be null
   * @param property the name of the property to be set
   * @param values the value(s) for the property; may be empty if 
   * any existing property is to be removed
   */
  void setProperty( String nodePath, String property, Object... values );

  /**
   * Set the supplied reference on the supplied node.
   *
   * @param nodePath the path to the node containing the property; 
   * may not be null
   * @param property the name of the property to be set
   * @param paths the paths to the referenced property, which may be
   * absolute paths or relative to the sequencer output node;
   * may be empty if any existing property is to be removed
   */
  void setReference( String nodePath, String property, String... paths );
}
 ]]></programlisting>
    <para>JBoss DNA will create nodes of type <code>nt:unstructured</code> unless you specify the value for the
      <code>jcr:primaryType</code> property.  You can also specify the values for the <code>jcr:mixinTypes</code> property
      if you want to add mixins to any node.</para>
    <para>For a complete example of a sequencer, let's look at the <code>org.jboss.dna.sequencers.image.ImageMetadataSequencer</code> 
			implementation:</para>
    <programlisting role="JAVA"><![CDATA[
public class ImageMetadataSequencer implements StreamSequencer {

    public static final String METADATA_NODE = "image:metadata";
    public static final String IMAGE_PRIMARY_TYPE = "jcr:primaryType";
    public static final String IMAGE_MIXINS = "jcr:mixinTypes";
    public static final String IMAGE_MIME_TYPE = "jcr:mimeType";
    public static final String IMAGE_ENCODING = "jcr:encoding";
    public static final String IMAGE_FORMAT_NAME = "image:formatName";
    public static final String IMAGE_WIDTH = "image:width";
    public static final String IMAGE_HEIGHT = "image:height";
    public static final String IMAGE_BITS_PER_PIXEL = "image:bitsPerPixel";
    public static final String IMAGE_PROGRESSIVE = "image:progressive";
    public static final String IMAGE_NUMBER_OF_IMAGES = "image:numberOfImages";
    public static final String IMAGE_PHYSICAL_WIDTH_DPI = "image:physicalWidthDpi";
    public static final String IMAGE_PHYSICAL_HEIGHT_DPI = "image:physicalHeightDpi";
    public static final String IMAGE_PHYSICAL_WIDTH_INCHES = "image:physicalWidthInches";
    public static final String IMAGE_PHYSICAL_HEIGHT_INCHES = "image:physicalHeightInches";

    /**
     * {@inheritDoc}
     */
    public void sequence( InputStream stream, SequencerOutput output, 
                          SequencerContext context ) {
        ImageMetadata metadata = new ImageMetadata();
        metadata.setInput(stream);
        metadata.setDetermineImageNumber(true);
        metadata.setCollectComments(true);

        // Process the image stream and extract the metadata ...
        if (!metadata.check()) {
            metadata = null;
        }

        // Generate the output graph if we found useful metadata ...
        if (metadata != null) {
            // Place the image metadata into the output map ...
            output.setProperty(METADATA_NODE, IMAGE_PRIMARY_TYPE, "image:metadata");
            // output.psetProperty(METADATA_NODE, IMAGE_MIXINS, "");
            output.setProperty(METADATA_NODE, IMAGE_MIME_TYPE, metadata.getMimeType());
            // output.setProperty(METADATA_NODE, IMAGE_ENCODING, "");
            output.setProperty(METADATA_NODE, IMAGE_FORMAT_NAME, metadata.getFormatName());
            output.setProperty(METADATA_NODE, IMAGE_WIDTH, metadata.getWidth());
            output.setProperty(METADATA_NODE, IMAGE_HEIGHT, metadata.getHeight());
            output.setProperty(METADATA_NODE, IMAGE_BITS_PER_PIXEL, metadata.getBitsPerPixel());
            output.setProperty(METADATA_NODE, IMAGE_PROGRESSIVE, metadata.isProgressive());
            output.setProperty(METADATA_NODE, IMAGE_NUMBER_OF_IMAGES, metadata.getNumberOfImages());
            output.setProperty(METADATA_NODE, IMAGE_PHYSICAL_WIDTH_DPI, metadata.getPhysicalWidthDpi());
            output.setProperty(METADATA_NODE, IMAGE_PHYSICAL_HEIGHT_DPI, metadata.getPhysicalHeightDpi());
            output.setProperty(METADATA_NODE, IMAGE_PHYSICAL_WIDTH_INCHES, metadata.getPhysicalWidthInch());
            output.setProperty(METADATA_NODE, IMAGE_PHYSICAL_HEIGHT_INCHES, metadata.getPhysicalHeightInch());
        }
    }
}
 ]]></programlisting>
    <para>
    Notice how the image metadata is extracted and the output graph is generated.  A single node is created with the name <code>image:metadata</code>
    and with the <code>image:metadata</code> node type.  No mixins are defined for the node, but several properties are set on the node
    using the values obtained from the image metadata.  After this method returns, the constructed graph will be saved to the repository
    in all of the places defined by its configuration.  (This is why only relative paths are used in the sequencer.)
	</para>
  </sect1>
  <sect1 id="testing_custom_sequencers">
    <title>Testing custom sequencers</title>
    <para>The sequencing framework was designed to make testing sequencers much easier.  In particular, the
    <code>StreamSequencer</code> interface does not make use of the JCR API.  So instead of requiring a fully-configured
    JCR repository and JBoss DNA system, unit tests for a sequencer can focus on testing that the content is
    processed correctly and the desired output graph is generated.</para>
    <note>
      <para>For a complete example of a sequencer unit test, see the <code>ImageMetadataSequencerTest</code> unit test
      in the <code>org.jboss.dna.sequencer.images</code> package of the <code>dna-sequencers-image</code> project.
      </para>
    </note>
    <para>The following code fragment shows one way of testing a sequencer, using JUnit 4.4 assertions and 
      some of the classes made available by JBoss DNA.  Of course,
      this example code does not do any error handling and does not make all the assertions a real test would.</para>
    <programlisting role="JAVA"><![CDATA[
Sequencer sequencer = new ImageMetadataSequencer();
MockSequencerOutput output = new MockSequencerOutput();
MockSequencerContext context = new MockSequencerContext();
InputStream stream = null;
try {
    stream = this.getClass().getClassLoader().getResource("caution.gif").openStream();
    sequencer.sequence(stream,output,context);   // writes to 'output'
    assertThat(output.getPropertyValues("image:metadata", "jcr:primaryType"), 
               is(new Object[] {"image:metadata"}));
    assertThat(output.getPropertyValues("image:metadata", "jcr:mimeType"), 
               is(new Object[] {"image/gif"}));
    // ... make more assertions here
    assertThat(output.hasReferences(), is(false));
} finally {
    stream.close();
}
 ]]></programlisting>
  <para>It's also useful to test that a sequencer produces no output for something it should not understand:</para>
    <programlisting role="JAVA"><![CDATA[
Sequencer sequencer = new ImageMetadataSequencer();
MockSequencerOutput output = new MockSequencerOutput();
MockSequencerContext context = new MockSequencerContext();
InputStream stream = null;
try {
    stream = this.getClass().getClassLoader().getResource("caution.pict").openStream();
    sequencer.sequence(stream,output,context);   // writes to 'output'
    assertThat(output.hasProperties(), is(false));
    assertThat(output.hasReferences(), is(false));
} finally {
    stream.close();
}
 ]]></programlisting>
    <para>These are just two simple tests that show ways of testing a sequencer.  Some tests may get quite involved,
    especially if a lot of output data is produced.  
    </para>
    <para>It may also be useful to create some integration tests
    that <link linkend="using_dna">configure JBoss DNA</link> to use a custom sequencer, and to then upload
    content using the JCR API, verifying that the custom sequencer did run.  However, remember that JBoss DNA
    runs sequencers asynchronously in the background, and you must sychronize your tests to ensure that the
    sequencers have a chance to run before checking the results.  (One way of doing this (although, granted, not always reliable) is to wait for a second
    after uploading your content, shutdown the <code>SequencingService</code> and await its termination,
    and then check that the sequencer output has been saved to the JCR repository.  For an example of this technique,
    see the <code>SequencingClientTest</code> unit test in the example application.)
    </para>  
  </sect1>
  <sect1 id="deploying_custom_sequencers">
    <title>Deploying custom sequencers</title>
    <para>The first step of deploying a sequencer consists of adding/changing the sequencer configuration (e.g., <code>SequencerConfig</code>)
    in the <code>SequencingService</code>.  This was covered in the <link linkend="sequencing_service">previous chapter</link>.
    </para>
    <para>
    The second step is to make the sequencer implementation available to JBoss DNA.  At this time, the JAR containing 
    your new sequencer, as well as any JARs that your sequencer depends on, should be placed on your application classpath.</para>
    <note>
      <para>A future goal of JBoss DNA is to allow sequencers, connectors, and other extensions to be easily deployed into
        a runtime repository.  This process will not only be much simpler, but it will also provide JBoss DNA 
        with the information necessary to update configurations and create the appropriate class loaders for each extension.
        Having separate class loaders for each extension helps prevent the pollution of the common classpath, 
        facilitates an isolated runtime environment to eliminate any dependency conflicts, and may potentially
        enable hot redeployment of newer extension versions.
      </para>
    </note>
  </sect1>
</chapter>
