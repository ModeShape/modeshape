<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ ModeShape (http://www.modeshape.org)
  ~
  ~ See the COPYRIGHT.txt file distributed with this work for information
  ~ regarding copyright ownership.  Some portions may be licensed
  ~ to Red Hat, Inc. under one or more contributor license agreements.
  ~ See the AUTHORS.txt file in the distribution for a full listing of 
  ~ individual contributors.
  ~
  ~ ModeShape is free software. Unless otherwise indicated, all code in ModeShape
  ~ is licensed to you under the terms of the GNU Lesser General Public License as
  ~ published by the Free Software Foundation; either version 2.1 of
  ~ the License, or (at your option) any later version.
  ~
  ~ ModeShape is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd	" [
<!ENTITY % CustomDTD SYSTEM "../custom.dtd">
%CustomDTD;
]>
<chapter id="using_modeshape">
	<title>Using ModeShape</title>
	<para>Using ModeShape within your application is actually quite straightforward.  As you'll see in this chapter,
		the first step is setting up ModeShape and starting the <code>JcrEngine</code>.  After that, you obtain the
		<code>javax.jcr.Repository</code> instance for a named repository and just use the standard JCR API throughout your
		application.
	</para>
	<sect1 id="jcr_engine">
		<title>ModeShape's JcrEngine</title>
		<para>
			ModeShape encapsulates everything necessary to run one or more JCR repositories into a single &JcrEngine; instance.
			This includes all underlying repository sources, the pools of connections to the sources, the sequencers,
			the MIME type detector(s), and the &Repository; implementations.
		</para>
		<para>
			Obtaining a &JcrEngine; instance is very easy - assuming that you have a valid &JcrConfiguration; instance.  We'll see
			how to get one of those in a little bit, but if you have one then all you have to do is build and start the engine:
		</para>
    <programlisting role="JAVA"><![CDATA[JcrConfiguration config = ...
JcrEngine engine = config.build();
engine.start();]]></programlisting>
		<para>
			Obtaining a JCR &Repository; instance is a matter of simply asking the engine for it by the name defined in the configuration:
		</para>
    <programlisting role="JAVA"><![CDATA[javax.jcr.Repository repository = engine.getRepository("Name of repository");]]></programlisting>
		<para>
			At this point, your application can proceed by working with the JCR API.
		</para>
		<para>
			And, once you're finished with the &JcrEngine;, you should shut it down:
		</para>
    <programlisting role="JAVA"><![CDATA[engine.shutdown();
engine.awaitTermination(3,TimeUnit.SECONDS);	// optional]]></programlisting>
		<para>
			When the <code>shutdown()</code> method is called, the &Repository; instances managed by the engine are marked as being shut down,
			and they will not be able to create new &Session;s.  However, any existing &Session;s or ongoing operations (e.g., event notifications)
			present at the time of the <code>shutdown()</code> call will be allowed to finish.  
			In essence, <code>shutdown()</code> is a <emphasis>graceful</emphasis> request, and since it may take some time to complete,
			you can wait until the shutdown has completed by simply calling <code>awaitTermination(...)</code> as shown above.
			This method will block until the engine has indeed shutdown or until the supplied time duration has passed (whichever comes first).
			And, yes, you can call the <code>awaitTermination(...)</code> method repeatedly if needed.
		</para>
	</sect1>
	<sect1 id="jcr_configuration">
		<title>JcrConfiguration</title>
		<para>
			The previous section assumed the existence of a &JcrConfiguration;.  Obtaining an instance isn't very difficult at all.
			In fact, there's only one no-argument constructor, so actually creating the instance is a piece of cake.  
			It can be a little more challenging to assemble the configuration you want to use.
		</para>
		<para>
			Each &JcrConfiguration; instance defines all of the components that will run inside the &JcrEngine;:
			<itemizedlist>
				<listitem>
					<para><emphasis role="strong"><code>Repository sources</code></emphasis> are the POJO objects that each describe a particular
					location where content is stored.  Each repository source object is an instance of a ModeShape connector, and is configured
					with the properties that particular source.  ModeShape's &RepositorySource; classes are analogous to JDBC's &DataSource; classes -
					they are implemented by specific connectors (aka, "drivers") for specific kinds of repository sources (aka, "databases").
					Similarly, a &RepositorySource; instance is analogous to a &DataSource; instance, with bean properties for each configurable
					parameter.  Therefore, each repository source definition must supply the name of the &RepositorySource; class, any
					bean properties, and, optionally, the classpath that should be used to load the class. </para>
				</listitem>
				<listitem>
					<para><emphasis role="strong"><code>Repositories</code></emphasis> define the JCR repositories that are available.  Each
					repository has a unique name that is used to obtain the &Repository; instance from the &JcrEngine;'s <code>getRepository(String)</code>
					method, but each repository definition also can include the predefined namespaces (other than those automatically defined by
					ModeShape), various options, and the node types that are to be available in the repository without explicit registration
					through the JCR API.</para>
				</listitem>
				<listitem>
					<para><emphasis role="strong"><code>Sequencers</code></emphasis> define the particular sequencers that are available for use.
					Each sequencer definition provides the path expressions governing which nodes in the repository should be sequenced when those nodes change,
					and where the resulting output generated by the sequencer should be placed.  The definition also must state the name of 
					the sequencer class, any bean properties and, optionally, the classpath that should be used to load the class.</para>
				</listitem>
				<listitem>
					<para><emphasis role="strong"><code>MIME type detectors</code></emphasis> define the particular MIME type detector(s) that should
					be made available.  A MIME type detector does exactly what the name implies: it attempts to determine the MIME type given a
					"filename" and contents.  ModeShape automatically uses a detector that uses the file extension to identify the MIME type,
					but also provides an implementation that uses an external library to identify the MIME type based upon the contents.
					The definition must state the name of the detector class, any bean properties and, optionally, the classpath that should 
					be used to load the class.</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			There really are three options for setting up a &JcrConfiguration; instance:
			<itemizedlist>
				<listitem>
					<para><emphasis role="strong"><code>Loading from a file</code></emphasis> is conceptually the easiest and requires the least amount
					of Java code, but it does require a configuration file. More on that in a bit.</para>
				</listitem>
				<listitem>
					<para><emphasis role="strong"><code>Loading from a configuration repository</code></emphasis> is not much more complicated than loading
					from a file, but it does allow multiple &JcrEngine; instances (usually in different processes perhaps on different machines)
					to easily access a shared, persistent configuration.  And technically, loading the configuration from a file really just
					imports the configuration file into	a transient &InMemoryRepositorySource;.</para>
				</listitem>
				<listitem>
					<para><emphasis role="strong"><code>Programmatic configuration</code></emphasis> is always possible, even if the configuration is loaded
					from a file or repository.  Using the &JcrConfiguration;'s API, you can define (or update or remove) all of the definitions that make
					up a configuration.</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			Each of these approaches has their obvious advantages, so the choice of which one to use is entirely up to you.
		</para>
		<sect2 id="loading_from_file">
			<title>Loading from a configuration file</title>
			<para>
				Loading the ModeShape configuration from a file is actually very simple:
			</para>
    	<programlisting role="JAVA"><![CDATA[JcrConfiguration config = new JcrConfiguration();
configuration.loadFrom(file);]]></programlisting>
			<para>
				where the <code>file</code> parameter can actually be a &File; instance, a &URL; to the file, an &InputStream; 
				containing the contents of the file, or even a &String; containing the path to the file.  
			</para>
			<note>
				<para>The <code>loadFrom(...)</code> methods can be called multiple times, but each time it completely wipes
				  out any current notion of the configuration and replaces it with the configuration found in the file.
				</para>
			</note>
			<para>
				There is an optional second parameter that defines the &Path; within the configuration file identifying the parent node of the various
				configuration nodes.  If not specified, it assumes "/".  This makes it possible for the configuration content to be
				at a different location in the hierarchical structure.  (This is not often required, but when it is required
				this second parameter is very useful.)
			</para>
			<para>
				Here is the configuration file that is used in the repository example, though it has been simplified a bit and most comments 
				have been removed for clarity):
			</para>
    	<programlisting role="XML"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<configuration xmlns:mode="http://www.modeshape.org/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0">
	  <!-- 
	  Define the JCR repositories 
	  -->
	  <mode:repositories>
	      <!-- 
	      Define a JCR repository that accesses the 'Cars' source directly.
	      -->
	      <mode:repository jcr:name="car repository" mode:source="Cars">
	          <mode:options jcr:primaryType="mode:options">
	              <jaasLoginConfigName jcr:primaryType="mode:option" mode:value="modeshape-jcr"/>
	              <!--
	              As a convenience, ModeShape defaults to granting guest users full access.  
	              In a production system, you would want to limit this access by uncommenting one of the 
	              options below:
	              
	              for no access:
	              <anonymousUserRoles jcr:PrimaryType="mode:option" mode:value="" />
	              
	              for read-only acces:
	              <anonymousUserRoles jcr:PrimaryType="mode:option" mode:value="readonly" /> 
	              -->
	          </mode:options>
	      </mode:repository>
	  </mode:repositories>
    <!-- 
    Define the sources for the content.  These sources are directly accessible using the ModeShape-specific 
    Graph API.
    -->
    <mode:sources jcr:primaryType="nt:unstructured">
        <mode:source jcr:name="Cars" 
                    mode:classname="org.modeshape.graph.connector.inmemory.InMemoryRepositorySource" 
                    mode:retryLimit="3" mode:defaultWorkspaceName="workspace1"/>
        <mode:source jcr:name="Aircraft" 
                    mode:classname="org.modeshape.graph.connector.inmemory.InMemoryRepositorySource">
            <!-- Define the name of the workspace used by default.  Optional, but convenient. -->
            <defaultWorkspaceName>workspace2</defaultWorkspaceName>
        </mode:source>
    </mode:sources>
    <!-- 
    Define the sequencers. This is an optional section. 
    -->
    <mode:sequencers>
        <mode:sequencer jcr:name="Image Sequencer" 
                       mode:classname="org.modeshape.sequencer.image.ImageMetadataSequencer">
            <mode:description>Image metadata sequencer</mode:description>        
            <mode:pathExpression>/foo/source => /foo/target</mode:pathExpression>
            <mode:pathExpression>/bar/source => /bar/target</mode:pathExpression>
        </mode:sequencer>
    </mode:sequencers>
    <!--
	  Define how ModeShape will determine the MIME type of files. This is an optional section 
	  (and the default works pretty well).
    -->
    <mode:mimeTypeDetectors>
        <mode:mimeTypeDetector jcr:name="Detector" 
                              mode:description="Standard extension-based MIME type detector"/>
    </mode:mimeTypeDetectors>
</configuration>]]></programlisting>
		</sect2>
		<sect2 id="loading_from_repository">
			<title>Loading from a configuration repository</title>
			<para>
				Loading the ModeShape configuration from an existing repository is also pretty straightforward.  Simply create and configure the
				&RepositorySource; instance to point to the desired repository, and then call the <code>loadFrom(&RepositorySource; source)</code>
				method:
			</para>
    	<programlisting role="JAVA"><![CDATA[RepositorySource configSource = ...
JcrConfiguration config = new JcrConfiguration();
configuration.loadFrom(configSource);]]></programlisting>
			<para>
				This really is a more advanced way to define your configuration, so we won't go into how you configure a &RepositorySource;.
				Suffice to say that you can create a &JcrConfiguration; that uses a &RepositorySource;, programmatically define the configuration,
				and call <code>save()</code> on the &JcrConfiguration; to store the configuration in the repository sources. To use that
				configuration, just create &JcrConfiguration; objects using a &RepositorySource; pointed to the same persistent store,
				and you're done.  For more information, consult the &ReferenceGuide;.
			</para>
			<para>
				If you use the <code>loadFrom(&RepositorySource;,&Path;)</code> form, you can control where the configuration content is
				stored in the repository.  This is useful if you want to store multiple configurations in the same repository.
			</para>
		</sect2>
		<sect2 id="programmatic_configuration">
			<title>Programmatic configuration</title>
			<para>
				Defining the configuration programmatically is not terribly complicated, and it for obvious reasons results in more verbose Java code.
				But this approach is very useful and often the easiest approach when the configuration must change or is a reflection of other
				dynamic information.
			</para>
			<para>
				The &JcrConfiguration; class was designed to have an easy-to-use API that makes it easy to configure each of the different kinds of
				components, especially when using an IDE with code completion.  Here are several examples:
			</para>
			<sect3 id="programmatically_configuring_sources">
				<title>Repository sources</title>
				<para>Each repository source definition must include the name of the &RepositorySource; class as well as each bean property
					that should be set on the object:
				</para>
    		<programlisting role="JAVA"><![CDATA[JcrConfiguration config = ...
config.repositorySource("source A")
      .usingClass(InMemoryRepositorySource.class)
      .setDescription("The repository for our content")
      .setProperty("defaultWorkspaceName", workspaceName);]]></programlisting>
				<para>
					This example defines an in-memory source with the name "source A", a description, and a single "defaultWorkspaceName" bean property.
					Different &RepositorySource; implementations will the bean properties that are required and optional.
					Of course, the class can be specified as Class reference or a string (followed by whether the class should be loaded from
					the classpath or from a specific classpath).
				</para>
				<note>
					<para>Each time <code>repositorySource(String)</code> is called, it will either load the existing definition with the supplied
					name or will create a new definition if one does not already exist.  To remove a definition, simply call <code>remove()</code>
					on the result of <code>repositorySource(String)</code>.
					The set of existing definitions can be accessed with the <code>repositorySources()</code> method.
					</para>
				</note>
			</sect3>
			<sect3 id="programmatically_configuring_repositories">
				<title>Repositories</title>
				<para>Each repository must be defined to use a named repository source, but all other aspects (e.g., namespaces, node types, options) 
					are optional.</para> 
<programlisting role="JAVA"><![CDATA[JcrConfiguration config = ...
config.repository("repository A")
      .addNodeTypes("myCustomNodeTypes.cnd")
      .setSource("source 1")
      .registerNamespace("acme","http://www.example.com/acme")
      .setOption(JcrRepository.Option.JAAS_LOGIN_CONFIG_NAME, "modeshape-jcr");
      
      /*
       * As a convenience, ModeShape allows guest users full access by default.  In a production system,
       * you would want to limit this access by adding one of the lines below to modify this option:
       * .setOption(JcrRepository.Option.ANONYMOUS_USER_ROLES, ""); // No access
       * .setOption(JcrRepository.Option.ANONYMOUS_USER_ROLES, "readonly"); // Read-only access
       */]]></programlisting>
				<para>
					This example defines a repository that uses the "source 1" repository source (which could be a federated source, an in-memory source,
					a database store, or any other source).  Additionally, this example adds the node types in the "myCustomNodeTypes.cnd" file as those
					that will be made available when the repository is accessed.  It also defines the "http://www.example.com/acme" namespace,
					and finally sets the "JAAS_LOGIN_CONFIG_NAME" option to define the name	of the JAAS login configuration that should be used by 
					the ModeShape repository.
				</para>
			</sect3>
			<sect3 id="programmatically_configuring_sequencers">
				<title>Sequencers</title>
				<para>Each defined sequencer must specify the name of the &StreamSequencer; implementation class as well as the path expressions
					defining which nodes should be sequenced and the output paths defining where the sequencer output should be placed (often as a function
					of the input path expression).</para> 
    		<programlisting role="JAVA"><![CDATA[JcrConfiguration config = ...
config.sequencer("Image Sequencer")
      .usingClass("org.modeshape.sequencer.image.ImageMetadataSequencer")
      .loadedFromClasspath()
      .setDescription("Sequences image files to extract the characteristics of the image")
      .sequencingFrom("//(*.(jpg|jpeg|gif|bmp|pcx|png|iff|ras|pbm|pgm|ppm|psd)[*])/jcr:content[@jcr:data]")
      .andOutputtingTo("/images/$1");]]></programlisting>
				<para>
					This shows an example of a sequencer definition named "Image Sequencer" that uses the &ImageMetadataSequencer; class 
					(loaded from the classpath), that is to sequence the "jcr:data" property on any new or changed nodes that are named 
					"jcr:content" below a parent node	with a name ending in ".jpg", ".jpeg", ".gif", ".bmp", ".pcx", ".iff", ".ras", 
					".pbm", ".pgm", ".ppm" or ".psd".  The output of the sequencing operation should be placed at the "/images/$1" node,
					where the "$1" value is captured as the name of the parent node.  (The capture groups work the same was as regular expressions;
					see the &ReferenceGuide; for more details.)
					Of course, the class can be specified as Class reference or a string (followed by whether the class should be loaded from
					the classpath or from a specific classpath).
				</para>
				<note>
					<para>Each time <code>sequencer(String)</code> is called, it will either load the existing definition with the supplied
					name or will create a new definition if one does not already exist.  To remove a definition, simply call <code>remove()</code>
					on the result of <code>sequencer(String)</code>.
					The set of existing definitions can be accessed with the <code>sequencers()</code> method.
					</para>
				</note>
			</sect3>
			<sect3 id="programmatically_configuring_mime_type_detectors">
				<title>MIME type detectors</title>
				<para>Each defined MIME type detector must specify the name of the &MimeTypeDetector; implementation class as well as any
					other bean properties required by the implementation.</para> 
    		<programlisting role="JAVA"><![CDATA[JcrConfiguration config = ...
config.mimeTypeDetector("Extension Detector")
      .usingClass(org.modeshape.graph.mimetype.ExtensionBasedMimeTypeDetector.class);]]></programlisting>
				<para>
					Of course, the class can be specified as Class reference or a string (followed by whether the class should be loaded from
					the classpath or from a specific classpath).
				</para>
				<note>
					<para>Each time <code>mimeTypeDetector(String)</code> is called, it will either load the existing definition with the supplied
					name or will create a new definition if one does not already exist.  To remove a definition, simply call <code>remove()</code>
					on the result of <code>mimeTypeDetector(String)</code>.  
					The set of existing definitions can be accessed with the <code>mimeTypeDetectors()</code> method.
					</para>
				</note>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="modeshape_and_jndi">
		<title>Deploying ModeShape via JNDI</title>
		<para>
			Sometimes your applications can simply define a &JcrConfiguration; and instantiate the &JcrEngine; instance directly.
			This is very straightforward, and this is what the <link linkend="downloading_and_running">ModeShape examples</link> do.
		</para>
		<para>
			Web applications are a different story. Often, you may not want your web application to contain the code that initializes
			a ModeShape engine.  Or, you may want the same &JcrEngine; instance to be reused in multiple web applications deployed 
			to the same web/application server. In these cases, it is possible to configure the web/app server's JNDI instance to
			instantiate the &JcrEngine;, meaning the web applications need only use the standard JNDI and JCR APIs.
		</para>
		<sect2 id="modeshape_and_jndi_application">
			<title>Example application using JCR and JNDI</title>
			<para>
				Here's an example of how such a web application would obtain a JCR &Repository; instance, use it to create a &JcrSession;,
				and then close the session when completed.  
			</para>
    	<programlisting role="JAVA"><![CDATA[Session session = null;

try {
  // Look up the JCR Repository object ...
	InitialContext initCtx = new InitialContext();
	Context envCtx = (Context) initCtx.lookup("java:comp/env");
	Repository repo = (Repository) envCtx.lookup("jcr/local");		// name in JNDI is defined by configuration
	
	// Obtain a JCR Session using simple authentication
	// (or use anonymous authentication if desired)
	session = repo.login(new SimpleCredentials("username", "password".toCharArray()));
	
	// Use the JCR Session to do something interesting
	
} catch (Exception ex) {
	ex.printStackTrace();
} finally {
	if (session != null) session.logout();
}]]></programlisting>
			<para>
				Note that the location of the &Repository; instance in JNDI depends upon the configuration. In this example, we used
				"<code>jcr/local</code>", but the only requirement is that it match the location where it was placed in JNDI.
			</para>
			<para>
				We showed how web applications can use an existing &Repository; instance. In the next section, we describe how to configure
				the web server so that the &Repository; instance is available in JNDI.
			</para>
		</sect2>
		<sect2 id="modeshape_and_jndi_configuring">
			<title>Configuring JCR and JNDI</title>
			<para>
				Each kind of web server or application server is different, but all servlet containers do provide a way of configuring
				objects and placing them into JNDI.  ModeShape provides a &JndiRepositoryFactory; class that implements &ObjectFactory;
				and that can be used in the server's configuration. The &JndiRepositoryFactory; requires two properties:
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="strong"><code>configFile</code></emphasis> is the path to the 
							<link linkend="loading_from_file">configuration file</link> resource, which must be available on the classpath
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="strong"><code>repositoryName</code></emphasis> is the name of a JCR repository that exists
							in the &JcrConfiguration; and that will be made available by this JNDI entry
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Here's an example of a fragment of the <code>conf/context.xml</code> for Tomcat:
			</para>
<programlisting role="XML"><![CDATA[<Resource name="jcr/local" 
          auth="Container"
          type="javax.jcr.Repository"
          factory="org.modeshape.jcr.JndiRepositoryFactory"
          configFile="/resource/path/to/configuration.xml"
          repositoryName="Test Repository Source" />]]></programlisting>
			<para>
				Note that it is possible to have multiple <code>Resource</code> entries. The &JndiRepositoryFactory; ensures
				that only one &JcrEngine; is instantiated, but that a &Repository; instance is registered for each entry.
			</para>
			<para>
				Before the server can start, however, all of the ModeShape jars need to be placed on the classpath for the server.
				JAAS also needs to be configured, and this can be done using the application server's configuration or in your
				web application if you're using a simple servlet container. For more details, see the &ReferenceGuide;.
			</para>
			<note>
				<para>
					The ModeShape community has solicited input on how we can make it easier to consume and use ModeShape in applications
					that do not use Maven. Check out the <ulink url="http://community.jboss.org/thread/146589">discussion thread</ulink>,
					and please add any suggestions or opinions!
				</para>
			</note>
			<para>
				Then, your web application needs to reference the <code>Resource</code> and state its requirements in its 
				<code>web.xml</code>:
			</para>
<programlisting role="XML"><![CDATA[<resource-env-ref>
   <description>Repository</description>
   <resource-env-ref-name>jcr/local</resource-env-ref-name>
   <resource-env-ref-type>javax.jcr.Repository</resource-env-ref-type>
</resource-env-ref>]]></programlisting>
			<para>
				Note that the value of <code>resource-env-ref-name</code> matches the value of the name attribute on the 
				<code>&lt;Resource></code> tag in the <code>context.xml</code> described above.  This is a must.
			</para>
			<para>
				At this point, your web application can perform the lookup of the &Repository; object, create and use a &Session;,
				and then close the &Session;.  Here's an example of a JSP page that does this:
			</para>
<programlisting role="JAVA"><![CDATA[
<%@ page import="javax.naming.*, javax.jcr.*, org.jboss.security.config.IDTrustConfiguration" %>
<%!

static {
	// Initialize IDTrust
	IDTrustConfiguration idtrustConfig = new IDTrustConfiguration();
	try {
	    idtrustConfig.config("security/jaas.conf.xml");
	} catch (Exception ex) {
	    throw new IllegalStateException(ex);
	}
}
%>
<%
Session sess = null;
try {
	InitialContext initCtx = new InitialContext();
	Context envCtx = (Context) initCtx.lookup("java:comp/env");
	Repository repo = (Repository) envCtx.lookup("jcr/local");
	sess = repo.login(new SimpleCredentials("readwrite", "readwrite".toCharArray()));

	// Do something interesting with the Session ...
	out.println(sess.getRootNode().getPrimaryNodeType().getName());
} catch (Exception ex) {
	ex.printStackTrace();
} finally {
	if (sess != null) sess.logout();
}
%>
]]></programlisting>			
			<para>
				Since this uses a servlet container, there is no JAAS implementation configured, so note the 
				loading of IDTrust to create the JAAS realm.  (To make this work in Tomcat, the security
				folder that contains the <code>jaas.conf.xml</code>, <code>users.properties</code>, and
				<code>roles.properties</code> needs to be moved into the <code>%CATALINA_HOME%</code> directory.)
			</para>
			<note>
				<para>
				If you use an application server such as <ulink url="http://www.jboss.com/products/platforms/application/">JBoss EAP</ulink>,
				you could just configure the JAAS realm as part of the server configuration and be done with it.
			  </para>
			</note>
		</sect2>
	</sect1>
	<sect1 id="using_modeshape_via_maven">
		<title>Using ModeShape via Maven</title>
		<para>
			ModeShape is a Maven-based project. If your application is using Maven, it is very easy to add a dependency on 
			ModeShape's JCR library (plus any extensions), and Maven will ensure your application has access to all 
			of the ModeShape artifacts and all 3rd-party libraries upon which ModeShape depends. 
			Simply add a dependency in your application's POM:
		</para>
<programlisting role="XML"><![CDATA[<dependency>
  <groupId>org.modeshape</groupId>
  <artifactId>modeshape-jcr</artifactId>
  <version>1.0.0.Final</version>
</dependency>
]]></programlisting>
			<para>
				plus dependencies for each optional extension (sequencers, connectors, MIME type detectors, etc.):
			</para>
<programlisting role="XML"><![CDATA[<dependency>
  <groupId>org.modeshape</groupId>
  <artifactId>modeshape-connector-store-jpa</artifactId>
  <version>0.7</version>
</dependency>
...
<dependency>
  <groupId>org.modeshape</groupId>
  <artifactId>modeshape-sequencer-java</artifactId>
  <version>1.0.0.Final</version>
</dependency>
]]></programlisting>
		<para>
			Then, continue by defining a &JcrConfiguration; and building the engine, as discussed <link linkend="jcr-engine">earlier</link>.
			This is very straightforward, and this is exactly what the <link linkend="downloading_and_running">ModeShape examples</link> do.
		</para>
		<note>
			<para>
				The ModeShape community has solicited input on how we can make it easier to consume and use ModeShape in applications
				that do not use Maven. Check out the <ulink url="http://community.jboss.org/thread/146589">discussion thread</ulink>,
				and please add any suggestions or opinions!
			</para>
		</note>
	</sect1>
	<sect1 id="using_modeshape_whats_next">
		<title>What's next</title>
		<para>
			This chapter outline how you configure ModeShape, how you then access a <code>javax.jcr.Repository</code> instance,
			and use the standard JCR API to interact with the repository. The
			<link linkend="downloading_and_running">next chapter </link> walks you through downloading
			and running the ModeShape examples. 
		</para>
	</sect1>
</chapter>
