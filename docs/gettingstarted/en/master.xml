<!--
  ~ JBoss, Home of Professional Open Source.
  ~
  ~ Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat Middleware LLC.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY % RH-ENTITIES SYSTEM "Common_Config/rh-entities.ent">
<!ENTITY versionNumber "0.1">
<!ENTITY copyrightYear "2008">
<!ENTITY copyrightHolder "Red Hat Middleware, LLC.">]>
<book>
  <bookinfo>
    <title>JBoss DNA</title>
    <subtitle>Getting Started Guide</subtitle>
    <releaseinfo>&versionNumber;</releaseinfo>
    <productnumber>&versionNumber;</productnumber>
    <issuenum>1</issuenum>
    <mediaobject>
        <imageobject role="fo">
            <imagedata fileref="images/dna-logo.png" align="center" />
        </imageobject>
        <imageobject role="pdf">
            <imagedata fileref="images/dna-logo.png" scale="75" align="center" />
        </imageobject>
        <imageobject role="html">
            <imagedata fileref="images/dna-logo.png" depth="3cm" />
        </imageobject>
        <imageobject role="xhtml">
            <imagedata fileref="images/dna-logo.png" depth="3cm" />
        </imageobject>
        <imageobject role="xhtml_single">
            <imagedata fileref="images/dna-logo.png" depth="3cm" />
        </imageobject>
    </mediaobject>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Author_Group.xml" />
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Legal_Notice.xml" />
  </bookinfo>
  <preface id="preface" revision="1">
    <title>What this book covers</title>
    <para>The goal of this book is to help you learn about JBoss DNA and how you can use it in your own applications to get the
      most out of your JCR repositories.</para>
    <para>The first part of the book starts out with an introduction to content repositories and an overview of the JCR API, both of
      which are an important aspect of JBoss DNA. This is followed by an overview of the JBoss DNA project, it's architecture,
      and a basic roadmap for what's coming next.</para>
    <para>The next part of the book covers how to download and build the examples, how to use JBoss DNA with existing
      repositories, and how to build and use custom sequencers.</para>
    <para>
      If you have any questions or comments, please feel free to contact JBoss DNA's
      <ulink url="mailto:dna-users@jboss.org">user mailing list</ulink>
      or use the
      <ulink url="http://www.jboss.com/index.html?module=bb&amp;op=viewforum&amp;f=272">user forums</ulink>
      . If you'd like to get involved on the project, join the
      <ulink url="http://www.jboss.org/dna/lists.html">mailing lists</ulink>
      ,
      <ulink url="http://www.jboss.org/dna/subversion.html">download the code</ulink>
      and get it building, and visit our
      <ulink url="http://jira.jboss.org/jira/browse/DNA">JIRA issue management system</ulink>
      . If there's something in particular you're interested in, talk with the community - there may be others interested in the
      same thing.
    </para>
  </preface>
  <chapter id="introduction">
    <title>Introduction</title>
    <para>There are a lot of choices for how applications can store information persistently so that it can be accessed at a
      later time and by other processes. The challenge developers face is to use an approach that most closely matches the needs of
      their application. This choice is more important as developers choose to focus their efforts on the application-specific
      logic, delegating much of the responsibilities for persistence to libraries and frameworks.</para>
    <para>
      Perhaps one of the easiest techniques is to simply store information in
      <emphasis>files</emphasis>
      . The Java language makes working with files relatively easy, but Java really doesn't provide many bells and whistles. So
      using files is an easy choice when the information is either not complicated (for example property files), or when users may
      need to read or change the information outside of the application (for example log files or configuration files). But using
      files to persist information becomes more difficult as the information becomes more complex, as the volume of it increases,
      or if it needs to be accessed by multiple processes. For these situations, other techniques are often a better choice.
    </para>
    <para>
      Another technique built into the Java language is
      <emphasis>Java serialization</emphasis>
      , which is capable of persisting the state of an object graph so that it can be read back in at a later time. However, Java
      serialization can quickly become tricky if the classes are changed, and so its beneficial usually when the information is
      persisted for a very short period of time. For example, serialization is sometimes used to send an object graph from one
      process to another.
    </para>
    <para>
      One of the more popular persistence technologies is the
      <emphasis>relational database</emphasis>
      . Relational database management systems have been around for decades and are very capable. The Java Database Connectivity
      (JDBC) API provides a standard interface for connecting to and interacting with relational databases. However, it is a
      low-level API that requires a lot of code to use correctly, and it still doesn't abstract away the DBMS-specific SQL
      grammar. Also, working with relational data in an object-oriented language can feel somewhat unnatural, so many developers
      map this data to classes that fit much more cleanly into their application. The problem is that manually creating this
      mapping layer requires a lot of repetitive and non-trivial JDBC code.
    </para>
    <para>
      <emphasis>Object-relational mapping</emphasis>
      libraries automate the creation of this mapping layer and result in far less code that is much more maintainable with often
      as good (if not better) performance than handwritten JDBC code. The new
      <ulink url="http://java.sun.com/developer/technicalArticles/J2EE/jpa/">Java Persistence API (JPA)</ulink>
      provide a standard mechanism for defining the mappings (through annotations) and working with these entity objects. Several
      commercial and open-source libraries implement JPA, and some even offer additional capabilities and features that go beyond
      JPA. For example,
      <ulink url="http://www.hibernate.org">Hibernate</ulink>
      is one of the most feature-rich JPA implementations and offers object caching, statement caching, extra association
      mappings, and other features that help to improve performance and usefulness.
    </para>
    <para>
      While relational databases and JPA are solutions that work for many applications, they become more limited in cases when the
      information structure is highly flexible, is not known a priori, or is subject to frequent change and customization. In
      these situations,
      <emphasis>content repositories</emphasis>
      may offer a better choice for persistence. Content repositories are almost a hybrid between relational databases and file
      systems, and typically provide other capabilies as well, including versioning, indexing, search, access control,
      transactions, and observation. Because of this, content repositories are used by content management systems (CMS), document
      management systems (DMS), and other applications that manage electronic files (e.g., documents, images, multi-media, web
      content, etc.) and metadata associated with them (e.g., author, date, status, security information, etc.). The
      <ulink url="http://www.jcp.org/en/jsr/detail?id=170">Content Repository for Java technology API</ulink>
      provides a standard Java API for working with content repositories. Abbreviated "JCR", this API was developed as part of the
      Java Community Process under
      <ulink url="http://www.jcp.org/en/jsr/detail?id=170">JSR-170</ulink>
      and is being revised under
      <ulink url="http://www.jcp.org/en/jsr/detail?id=283">JSR-283</ulink>
      .
    </para>
    <para>
      The
      <emphasis>JBoss DNA project</emphasis>
      is building the tooles and services that surround content repositories. Nearly all of these capabilities are to be hidden
      below the JCR API and involve automated processing of the information in the repository. Thus, JBoss DNA can add value to
      existing repository implementations. For example, JCR repositories offer the ability to upload files into the repository and
      have the file content index for search purposes. JBoss DNA defines a library for also sequencing that content to extract
      meaningful information and store it in the repository, where it can then be searched, accessed and analyzed using the JCR
      API.
    </para>
    <para> JBoss DNA is building other features as well. One goal of JBoss DNA is to create federated repositories that
      dynamically merge the information from multiple databases, services, applications, and other JCR repositories. Another is to
      create customized views based upon the type of data and the role of the user that is accessing the data. And yet another is
      to create a REST-ful API to allow the JCR content to be accessed easily by other applications written in other languages.
    </para>
    <para>
      The
      <link linkend="jboss_dna">next chapter</link>
      in this book goes into more detail about JBoss DNA and its architecture, the different components, what's available now, and
      what's coming in future releases.
      <link linkend="downloading">Chapter 3</link>
      then provides instructions for downloading and compiling the sequencer examples for the current release.
      <link linkend="using_dna">Chapter 4</link>
      walks through these examples, while
      <link linkend="custom_sequencers">Chapter 5</link>
      goes over how to create custom sequencers. Finally,
      <link linkend="future_directions">Chapter 6</link>
      wraps things up.
    </para>
  </chapter>
  <chapter id="jboss_dna">
    <title>JBoss DNA</title>
    <sect1>
      <title>Overview</title>
      <para>JBoss DNA is a repository and set of tools that make it easy to capture, version, analyze, and understand the
        fundamental building blocks of information. As models, service and process definitions, schemas, source code, and other
        artifacts are added to the repository, JBoss DNA "sequences" the makeup of these components and extracts their structure
        and interdependencies. The JBoss DNA web application allows end users to access, visualize, and edit this information in
        the terminology and structure they are familiar with. Such domain-specific solutions can be easily created with little or
        no programming.</para>
      <para> JBoss DNA supports the Java Content Repository (JCR) standard and is able to provide a single integrated view of
        multiple repositories, external databases, services, and applications, ensuring that JBoss DNA has access to the latest
        and most reliable master data. For instance, DNA could provide in a single view valuable insight into the business
        processes and process-level services impacted by a change to in an intermediary web server operation defined via WSDL.
        Similarly, a user could quickly view and navigate the dependencies between the data source models and transformation
        information stored within a content repository, the code base stored within a version control system, and the database
        schemas used by an application.</para>
    </sect1>
    <sect1 id="architecture">
      <title>Architecture</title>
      <para>The architecture for JBoss DNA consists of several major components that will be built on top of standard APIs,
        including JCR, JDBC, JNDI and HTTP. The goal is to allow these components to be assembled as needed and add value on top
        of other DNA components or third-party systems that support the standard APIs.</para>
      <!-- mediaobject>
        <imageobject>
          <imagedata align="center" fileref="images/dna-architecture.png"/>
        </imageobject>
      </mediaobject -->
      <figure id="dna-architecture">
        <title>JBoss DNA Architecture</title>
        <graphic align="center" scale="60" fileref="images/dna-architecture.png" />
      </figure>
      <para>
        As shown in the diagram above, the major components are (starting at the top):
        <itemizedlist>
          <listitem>
            <para>
              <emphasis role="strong">DNA Eclipse Plugins</emphasis>
              enable Eclipse users to access the contents of a JBoss DNA repository.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">DNA JDBC Driver</emphasis>
              provides a driver implementation, allowing JDBC-aware applications to connect to and use a JBoss DNA repository.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">DNA Remote JCR</emphasis>
              is a client-side component for accessing remote JCR repositories.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">DNA Web Application</emphasis>
              is used by end users and domain experts to visualize, search, edit, change and tag the repository content. The web
              application uses views to define how different types of information are to be presented and edited in
              domain-specific ways. The goal is that this web application is easily customized and branded for inclusion into
              other solutions and application systems. The DNA Web Application operate upon any JCR-compliant repository, although
              it does rely upon the DNA analysis and templating services.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">DNA Publishing Server</emphasis>
              allows content to be downloaded, uploaded and edited using the Atom Publishing Protocol. With the DNA Publishing
              Server, the content of the repository can easily be created, read, edited and deleted using the standard HTTP
              operations of POST, GET, PUT and DELETE (respectively). More and more tools are being created that support working
              with Atom Publishing servers. The DNA Publishing Server operates upon any JCR-compliant repository.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">DNA WebDAV Server</emphasis>
              allows clients such as Microsoft Windows and Apple OS X to connect to, read and edit the content in the repository
              using the WebDAV standard. Since WebDAV is an extension of HTTP, web browsers are able to read (but not modify) the
              content served by a WebDAV compliant server. The DNA WebDAV Server operates upon any JCR-compliant repository.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">DNA Sequencers</emphasis>
              are pluggable components that make it possible for content to be uploaded to the repository and automatically
              processed to extract meaningful structure and place that structure in the repository. Once this information is in
              the repository, it can be viewed, edited, analyzed, searched, and related to other content. DNA defines a Java
              interface that sequencers must implement. DNA sequencers operate upon any JCR-compliant repository.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">DNA Analyses</emphasis>
              are pluggable components that analyze the content and the relationships between the content to generate reports or
              to answer queries. DNA will include some standard analyzers, like dependency analysis and similarity analysis, that
              are commonly needed by many different solutions. DNA analyzers operate upon any JCR-compliant repository.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">DNA Views</emphasis>
              are definitions of how types of information are to be presented in a user interface to allow for creation, reading,
              editing, and deletion of information. DNA view definitions consist of data stored in a JCR repository, and as such
              views can be easily added, changed or removed entirely by using the DNA Web Application, requiring no programming.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">DNA Federation</emphasis>
              is an implementation of the JCR API that builds the content within the repository by accessing and integrating
              information from multiple sources. DNA Federation allows the integration of external system, like other JCR
              repositories, databases, applications, and services.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">DNA Connectors</emphasis>
              are used to communicate with these external sources of information. In the federation engine, each source is able to
              contribute node structure and node properties to any part of the federated graph, although typically many connectors
              will contribute most of their information to isolated subgraphs. The result is that integration from a wide range of
              systems can be integrated and accessed through the DNA Web Application, DNA Publishing Server, and DNA WebDAV
              Server. Connectors also may optionally participate in distributed transactions by exposing an XAResource.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">DNA Maven</emphasis>
              is a classloader library compatible with Maven 2 project dependencies. This allows the creation of Java ClassLoader
              instances using Maven 2 style paths, and all dependencies are transitively managed and included.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect1>
    <sect1>
      <title>Sequencers</title>
      <para> The current JBoss DNA release contains a sequencing framework that is designed to sequence data (typically files)
        stored in a JCR repository to automatically extract meaningful and useful information. This additional information is then
        saved back into the repository, where it can be accessed and used.</para>
      <para> In other words, you can just upload various kinds of files into a JCR repository, and DNA automatically processes
        those files to extract meaningful structured information. For example, load DDL files into the repository, and let
        sequencers extract the structure and metadata for the database schema. Load Hibernate configuration files into the
        repository, and let sequencers extract the schema and mapping information. Load Java source into the repository, and let
        sequencers extract the class structure, JavaDoc, annotations. Load a PNG, JPEG, or other image into the repository, and
        let sequencers extract the metadata from the image and save it in the repository. The same with XSDs, WSDL, WS policies,
        UML, MetaMatrix models, etc.</para>
      <para>
        JBoss DNA sequencers sit on top of existing JCR repositories (including federated repositories) - it basically extracts
        more useful information from what's already stored in the repository. And it uses the existing JCR versioning system. Each
        sequencer typically processes a single kind of file format. The following sequencer is included in JBoss DNA:
        <itemizedlist>
          <listitem>
            <para>
              <emphasis role="strong">Image sequencer</emphasis>
              - A sequencer that processes the binary content of an image file, extracts the metadata for the image, and then
              writes that image metadata to the repository. Gets the file format, image resolution, number of bits per pixel and
              optionally number of images, comments and physical resolution from JPEG, GIF, BMP, PCX, PNG, IFF, RAS, PBM, PGM, PPM
              and PSD files. (This sequencer may be improved in the future to also extract EXIF metadata from JPEG files; see
              <ulink url="http://jira.jboss.org/jira/browse/DNA-26">DNA-26</ulink>
              .)
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        As the community develops additional sequencers, they will also be included in JBoss DNA. Some of those that have been
        identified as being useful include:
        <itemizedlist>
          <listitem>
            <para>
              <emphasis role="strong">XML Schema Document (XSD) Sequencer</emphasis>
              - Process XSD files and extract the various elements, attributes, complex types, simple types, and groups. (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-32">DNA-32</ulink>
              )
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">Web Service Definition Language (WSDL) Sequencer</emphasis>
              - Process WSDL files and extract the services, bindings, ports, operations, parameters, and other information. (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-33">DNA-33</ulink>
              )
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">Hibernate File Sequencer</emphasis>
              - Process Hibernate configuration (cfg.xml) and mapping (hbm.xml) files to extract the configuration and mapping
              information. (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-61">DNA-61</ulink>
              )
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">XML Metadata Interchange (XMI) Sequencer</emphasis>
              - Process XMI documents that contain UML models or models using another metamodel, extracting the model structure
              into the repository. (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-31">DNA-31</ulink>
              )
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">ZIP Archive Sequencer</emphasis>
              - Process ZIP archive files to extract (explode) the contents into the repository. (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-63">DNA-63</ulink>
              )
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">Java Archive (JAR) Sequencer</emphasis>
              - Process JAR files to extract (explode) the contents into the classes and file resources. (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-64">DNA-64</ulink>
              )
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">Java Class File Sequencer</emphasis>
              - Process Java class files (bytecode) to extract the class structure (including annotations) into the repository.
              (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-62">DNA-62</ulink>
              )
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">Java Source File Sequencer</emphasis>
              - Process Java source files to extract the class structure (including annotations) into the repository.
              (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-51">DNA-51</ulink>
              )
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">PDF Sequencer</emphasis>
              - Process PDF files to extract the document metadata, including table of contents. (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-50">DNA-50</ulink>
              )
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">Maven 2 POM Sequencer</emphasis>
              - Process Maven 2 Project Object Model (POM) files to extract the project information, dependencies, plugins, and
              other content. (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-24">DNA-24</ulink>
              )
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">Data Definition Language (DDL) Sequencer</emphasis>
              - Process various dialects of DDL, including that from Oracle, SQL Server, MySQL, PostgreSQL, and others. May need
              to be split up into a different sequencer for each dialect. (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-26">DNA-26</ulink>
              )
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="strong">MP3 and MP4 Sequencer</emphasis>
              - Process MP3 and MP4 audio files to extract the name of the song, artist, album, track number, and other metadata.
              (See
              <ulink url="http://jira.jboss.org/jira/browse/DNA-30">DNA-30</ulink>
              )
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        The
        <link linkend="using_dna">examples</link>
        in this book go into more detail about how sequencers are managed and used, and
        <link linkend="custom_sequencers">Chapter 5</link>
        goes into detail about how to write custom sequencers.
      </para>
    </sect1>
    <sect1>
      <title>Federation</title>
      <para>There is a lot of information stored in many of different places: databases, repositories, SCM systems,
        registries, file systems, services, etc. The purpose of the federation engine is to allow applications to use the JCR API
        to access that information as if it were all stored in a single JCR repository, but to really leave the information where
        it is.</para>
      <para>Why not just move the information into a JCR repository? Most likely there are existing applications that rely upon
        that information being where it is. If we were to move it, then all those applications would break. Or they'd have to be
        changed to use JCR. If the information is being used, the most practical thing is to leave it where it is.</para>
      <para>
        Then why not just copy the information into a JCR repository? Actually, there are times when it's perfectly reasonable to
        make a copy of the data. Perhaps the system managing the existing information cannot handle the additional load of more
        clients. Or, perhaps the information doesn't change, or it does change and we want snapshots that don't change. But more
        likely, the data
        <emphasis>does</emphasis>
        change. So if applications are to use the most current information and we make copies of the data, we have to keep the
        copies synchronized with the master. That's generally a lot of work.
      </para>
      <para>The JBoss DNA federation engine lets us leave the information where it is, yet lets client applications use the JCR
        API to access all the information without caring where the information really exists. If the underlying information
        changes, client applications using JCR observation will be notified of the changes. If a JBoss DNA federated repository is
        configured to allow updates, client applications can change the information in the repository and JBoss DNA will propagate
        those changes down to the original source.</para>
      <sect2>
        <title>Connectors</title>
        <para>
          The JBoss DNA federation engine will use connectors to interact with different information sources to get at the content
          in those systems. Some ideas for connectors include:
          <itemizedlist>
            <listitem>
              <para>
                <emphasis role="strong">JCR Repository Connector</emphasis>
                - Connect to and interact with other JCR repositories.
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="strong">File System Connector</emphasis>
                - Expose the files and directories on a file system through JCR.
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="strong">Maven 2 Repository Connector</emphasis>
                - Access and expose the contents of a Maven 2 repository (either on the local file system or via HTTP) through
                JCR.
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="strong">JDBC Metadata Connector</emphasis>
                - Connect to relational databases via JDBC and expose their schema as content in a repository.
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="strong">UDDI Connector</emphasis>
                - Interact with UDDI registries to integrate their content into a repository.
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="strong">SVN Connector</emphasis>
                - Interact with Subversion software configuration management (SCM) repositories to expose the managed resources
                through JCR. Consider using
                <ulink url="http://svnkit.com/">SVNkit</ulink>
                (dual license) library for API into Subversion.
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="strong">CVS Connector</emphasis>
                - Interact with CVS software configuration management (SCM) repositories, to expose the managed resources through
                JCR.
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="strong">JDBC Storage Connector</emphasis>
                - Store and access information in a relational database. Also useful for persisting information in the federated
                repository not stored elsewhere.
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="strong">Distributed Database Connector</emphasis>
                - Store and access information in a
                <ulink url="http://www.hypertable.org/">Hypertable</ulink>
                or
                <ulink url="http://hadoop.apache.org/hbase/">HBase</ulink>
                distributed databases. Also useful for persisting information in the federated repository not stored elsewhere.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          If the connectors allow the information they contribute to be updated, they must provide an
          <code>XAResource</code>
          implementation that can be used with a Java Transaction Service. Connectors that provide read-only access need not
          provide an implementation.
        </para>
      </sect2>
      <sect2>
        <title>Sources</title>
        <para>
          Each JBoss DNA federated repository is configured to federate and integrate information from one or more
          <emphasis>sources</emphasis>
          . Each source contains the configuration details (e.g., connection information, location, properties, options, etc.) for
          working with that particular source, as well as a reference to the connector that should be used to establish
          connections to the source. And of course, sources can be added or removed without having to stop and restart the
          federated repository.
        </para>
      </sect2>
      <sect2>
        <title>Building the unified graph</title>
        <para> The federation engine works by effectively building up a single graph by querying each source and merging or
          unifying the responses. This information is cached, which improves performance, reduces the number of (potentially
          expensive) remote calls, reduces the load on the sources, and helps mitigate problems with source availability. As
          clients interact with the repository, this cache is consulted first. When the requested portion of the graph (or
          "subgraph") is contained completely in the cache, it is retuned immediately. However, if any part of the requested
          subgraph is not in the cache, each source is consulted for their contributions to that subgraph, and any results are
          cached.</para>
        <para> This basic flow makes it possible for the federated repository to build up a local cache of the integrated graph
          (or at least the portions that are used by clients). In fact, the federated repository caches information in a manner
          that is similar to that of the Domain Name System (DNS). As sources are consulted for their contributions, the source
          also specifies whether it is the authoritative source for this information (some sources that are themselves federated
          may not be the information's authority), whether the information may be modified, the time-to-live (TTL) value (the time
          after which the cached information should be refreshed), and the expiration time (the time after which the cached
          information is no longer valid). In effect, the source has complete control over how the information it contributes is
          cached and used.</para>
        <para>
          The federated repository also needs to incorporate
          <emphasis>negative caching</emphasis>
          , which is storage of the knowledge that something does not exist. Sources can be configured to contribute information
          only below certain paths (e.g.,
          <code>/A/B/C</code>
          ), and the federation engine can take advantage of this by never consulting that source for contributions to information
          on other paths. However, below that path, any negative responses must also be cached (with appropriate TTL and expiry
          parameters) to prevent the exclusion of that source (in case the source has information to contribute at a later time)
          or the frequent checking with the source.
        </para>
      </sect2>
      <sect2>
        <title>Queries</title>
        <para> The JBoss DNA federated repository will also support queries against the integrated and unified graph. In some
          situations the query can be determined to apply to a single source, but in most situations the query must be planned
          (and possibly rewritten) such that it can be pushed down to all the appropriate sources. Also, the cached results must
          be consulted prior to returning the query results, as the results from one source might have contributions from another
          source.</para>
        <para> It is hoped that the MetaMatrix query engine can be used for this purpose, after it is open sourced. This engine
          implements sophisticated query planning and optimization techniques for working efficiently with multiple sources.
        </para>
      </sect2>
      <sect2>
        <title>Updates</title>
        <para>
          The JBoss DNA federated repositories also make it possible for client applications to make changes to the unified graph
          within the context of distributed transactions. According to the JCR API, client applications use the Java Transaction
          API (JTA) to control the boundaries of their transactions. Meanwhile, the federated repository uses a
          <ulink url="http://www.jboss.org/jbosstm/">distributed transaction service</ulink>
          to coordinate the XA resources provided by the connectors.
        </para>
        <para> It is quite possible that clients add properties to nodes in the unified graph, and that this information cannot be
          handled by the same underlying source that contributed to the node. In this case, the federated repository can be
          configured with a fallback source that will be used used to store this "extra" information.</para>
        <para>
          It is a goal that non-XA sources (i.e., sources that use connectors without XA resources) can participate in distributed
          transactions through the use of
          <emphasis>compensating transactions</emphasis>
          . Because the JBoss DNA federation engine implements the JCR observation system, it is capable of recording all of the
          changes made to the distributed graph (and those changes sent to each updatable source). Therefore, if a non-XA source
          is involved in a distributed transaction that must be rolled back, any changes made to non-XA sources can be undone. (Of
          course, this does not make the underlying source transactional: non-transactional sources still may expose the interim
          changes to other clients.)
        </para>
      </sect2>
      <sect2>
        <title>Events</title>
        <para> The JCR API supports observing a repository to receive notifications of additions, changes and deletions of nodes
          and properties. The JBoss DNA federated repository will support this API through two primary means.</para>
        <para> When the changes are made through the federated repository, the JBoss DNA federation engine is well aware of the
          set of changes that have been (or are being) made to the unified graph. These events are directly propagated to
          listeners.</para>
        <para> Sources have the ability to publish events, making it possible for the JBoss DNA federation engine and clients that
          have registered listeners to be notified of changes in the information managed by that source. These events are first
          processed by the federation engine and possibly altered based upon contributions from other sources. (The federation
          engine also uses these events to update or purge information in the cache, which may add to the event set.) The
          resulting (and possibly altered) event set is then sent to all client listeners.</para>
      </sect2>
    </sect1>
  </chapter>
  <!--  ====================================================================================================
                                                   Chapter 
        ====================================================================================================   -->
  <chapter id="downloading">
    <title>Downloading the examples</title>
    <para>JBoss DNA is built using Maven 2, so it's much easier to following along with the examples in this document if you
      install and configure Maven. Once this is done, you can very easily build the examples or even create a maven project that
      depends on the JBoss DNA JARs. Maven will automatically download the right versions of the JARs, including those other
      libraries on which JBoss DNA depends. Maven also makes it very easy to create an assembly of your final application so that
      you can package into a distributable form.</para>
    <para>
      The examples created for this User Guide use Maven2 to achieve exactly this so it is highly recommended that you
      <ulink url="http://www.jboss.org/file-access/default/members/dna/downloads/0.1/jboss-dna-0.1-gettingstarted-examples.zip">download</ulink>
      these first and take a look at how they work.
    </para>
    <note>
      <para>
        To build and run the examples you first need to install and configure Maven 2.0.7 (or higher), available from
        <ulink url="http://maven.apache.org/">http://maven.apache.org/</ulink>
      </para>
      <para>Installation is performed by downloading and unzipping the maven-2.0.7-bin.zip file to a convenient
        location on your local disk. Configuration consists of adding $MAVEN_HOME/bin to your path and adding the following
        profile to your ~/.m2/settings.xml file:</para>
      <programlisting role="XML" language="xml">&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;jboss.repository&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;          
          &lt;name&gt;!jboss.repository.off&lt;/name&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
      &lt;repositories&gt;
        &lt;repository&gt;
          &lt;id&gt;snapshots.jboss.org&lt;/id&gt;
          &lt;url&gt;http://snapshots.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/repository&gt;
        &lt;repository&gt;
          &lt;id&gt;repository.jboss.org&lt;/id&gt;
          &lt;url&gt;http://repository.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/repository&gt;
      &lt;/repositories&gt;
      &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
          &lt;id&gt;repository.jboss.org&lt;/id&gt;
          &lt;url&gt;http://repository.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
        &lt;pluginRepository&gt;
          &lt;id&gt;snapshots.jboss.org&lt;/id&gt;
          &lt;url&gt;http://snapshots.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
      &lt;/pluginRepositories&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;</programlisting>
        <para>This profile informs Maven of the two JBoss repositories (snapshots and releases) that are needed to download the JARs for JBoss DNA and all dependent libraries.</para>
      </note>
      <para>After you have configured Maven and extracted the examples to a working folder, you can go to the <code>examples</code>
           subdirectory and enter <code>mvn install</code> to perform a build.  Maven will automatically download all of the libraries
           that are needed by the build, saving them to your local machine.  (This means the next time you run <code>mvn install</code>,
           all the libraries will be local, and the build will run much faster.)
      </para>
      <para>The build is successful if you see the following:</para>
           <programlisting language="bash">$ mvn install
...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] Getting Started examples .............................. SUCCESS [2.106s]
[INFO] Sequencer Examples .................................... SUCCESS [9.768s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 12 seconds
[INFO] Finished at: Wed May 07 12:00:06 CDT 2008
[INFO] Final Memory: 14M/28M
[INFO] ------------------------------------------------------------------------
$ </programlisting>
           <para>If there are errors, check whether you have the correct version of Maven installed and that you've correctly updated
           your Maven settings as described above.</para>
           <para>
           The <link linkend="using_dna">next chapter</link> shows you how to run the examples and walks through the source code to
           show you how to use JBoss DNA.</para>
  </chapter>
<chapter id="using_dna">
  <title>Using JBoss DNA</title>
  <para>With this release, JBoss DNA is able to monitor existing JCR repositories and automatically sequence newly upload files and updated content.
  The information produced by the sequencers is saved to the repository, making it available to any repository client.
  Using JBoss DNA, therefore, consists of setting up the DNA Java components and connecting them to the JCR repositories.
  This chapter walks you through this process, using the examples downloaded in the <link linkend="downloading">previous chapter</link>.
  </para>
  <para>You will find all of the necessary files for the example in the <code>examples/sequencers</code> directory, which follows the 
  Maven Standard Directory Layout:
  <programlisting>
sequencers/pom.xml
          /src/main/assembly
                   /config
                   /java
                   /resources
              /test/java
                   /resources
  </programlisting>
  </para>
  <para>This example consists of a client application that sets up an in-memory JCR repository and that allows a user
  to upload files into that repository.  The client also sets up the DNA services with an image sequencer so that
  if any of the uploaded files are PNG, JPEG, GIF, BMP or other images, DNA will automatically extract the image's
  metadata (e.g., image format, physical size, pixel density, etc.) and store that in the repository.
  </para>
  <para>The example is comprised of 3 classes and 1 interface, located in the <code>src/main/java</code> directory:
  <programlisting>
org/jboss/example/dna/sequencers/ConsoleInput.java
                                /ImageInfo.java
                                /SequencingClient.java
                                /UserInterface.java
  </programlisting>
  </para>
  <para>
  <code>SequencingClient</code> is the class that contains the main application.  <code>ImageInfo</code> is a simple
  Java object that encapsulates metadata about an image (as generated by the sequencer), and used by the client to pass 
  information to the <code>UserInterface</code>, which is an interface with methods that will be called at
  runtime to request data from the user.  <code>ConsoleInput</code> is an implementation of this that creates a text user interface, 
  allowing the user to operate the client from the command line. We can easily create a graphical implementation of 
  <code>UserInterface</code> at a later date. We can also create a mock implementation for 
  testing purposes that simulates a user entering data. This allows us to check the behaviour of the client automatically using conventional 
  JUnit test cases, as demonstrated by the code in the <code>src/test/java</code> directory:
  <programlisting>
org/jboss/example/dna/sequencers/SequencingClientTest.java
                                /MockUserInterface.java
  </programlisting>
  </para>
  <para>
  As mentioned in the <ulink url="downloading">previous chapter</ulink>, simply type <code>mvn package</code> from the <code>example/sequencer</code>
  directory to compile the source code, run the unit tests, build a client JAR and assemble a distribution containing all of the necessary files. 
  </para>
  <para>If you successfully built the examples, there will be a <code>examples/sequencers/target/dna-example-sequencers-basic.dir/</code>
  directory that contains the following:
  <itemizedlist>
	<listitem>
	  <para><emphasis role="strong"><code>run.sh</code></emphasis> is the *nix shell script that will run the example.</para>
    </listitem>
  <listitem>
    <para>
      <emphasis role="strong">
        <code>log4j.properties</code>
      </emphasis>
      is the Log4J configuration file.
    </para>
  </listitem>
  <listitem>
    <para>
      <emphasis role="strong">
        <code>jackrabbitConfig.xml</code>
      </emphasis>
      is the Jackrabbit configuration file, which is set up to use a transient in-memory repository.
    </para>
  </listitem>
  <listitem>
    <para>
      <emphasis role="strong">
        <code>jackrabbitNodeTypes.cnd</code>
      </emphasis>
      defines the additional JCR node types used by this example.
    </para>
  </listitem>
  <listitem>
    <para>
      <emphasis role="strong">
        <code>caution.gif</code>
      </emphasis>, <emphasis role="strong">
        <code>caution.png</code>
      </emphasis>, and <emphasis role="strong">
        <code>caution.jpg</code>
      </emphasis>
      are images that you'll use later and upload into the repository.
    </para>
  </listitem>
  <listitem>
    <para>
      <emphasis role="strong">
        <code>lib</code>
      </emphasis>
      subdirectory contains the JARs for all of the JBoss DNA artifacts as well as those for other libraries required
  by JBoss DNA and the example.
    </para>
  </listitem>
  </itemizedlist>
  <note>
    <para>JBoss DNA 0.1 and the examples are currently tested with <ulink url="http://jackrabbit.apache.org/">Apache Jackrabbit</ulink> version 1.3.3.  
    This version is stable and used by a number of other projects and applications.  However, you should be able to use a newer
    version of Jackrabbit, as long as that version uses the same JCR API.  For example, version 1.4.2 was released on March 26, 2008 and
    should be compatible.
    </para>
    <para>Just remember, if the version of Jackrabbit you want to use for these examples is not in the Maven repository,
    you'll have to either add it or add it locally.  For more information, see the <ulink url="http://maven.apache.org/">Maven documentation</ulink>.
    </para>
  </note>
  </para>
  <para>
  To run the client application, go to the <code>examples/sequencers/target/dna-example-sequencers-basic.dir/</code>
  directory and type <code>./run.sh</code>.  You should see the command line client and its menus in your terminal:
  <figure id="xample-sequencer-cli-client">
    <title>Example Client</title>
    <graphic align="center" scale="100" fileref="images/example-sequencer-cli-client.png" />
  </figure>
  From this menu, you can upload a file into the repository, search for images in the repository, print sequencing statistics, or quit the application.
  </para>
  <para>
  The first step is to upload one of the example images.  If you type 'u' and press return, you'll be prompted
  to supply the path to the file you want to upload.  Since the application is running from within the 
  <code>examples/sequencers/target/dna-example-sequencers-basic.dir/</code> directory, you can specify any 
  of the files in that directory without specifying the path:
  <figure id="example-sequencer-upload">
    <title>Uploading an image using the Example Client</title>
    <graphic align="center" scale="100" fileref="images/example-sequencer-upload.png" />
  </figure>
  However, you can specify any fully-qualified or relative path.  The application will notify you if it cannot
  find the file you specified.
  </para>
  <para>
  After you specified the file you want to upload, the example application asks you where in the repository you'd
  like to place the file.  (If you want to use the suggested location, just press <code>return</code>.)
  The client application uses the JCR API to upload the file to that location in the repository, creating any nodes (of type <code>nt:folder</code>) 
  for any directories that don't exist, and creating a node (of type <code>nt:file</code>) for the file.  And,
  per the JCR specification, the application creates a <code>jcr:content</code> node (of type <code>nt:resource</code>)
  under the file node.  The file contents are placed on this <code>jcr:content</code> node in the <code>jcr:data</code> property.
  For example, if you specify <code>/a/b/caution.png</code>, the following structure will be created in the repository:
  <programlisting>
  /a   (nt:folder)
    /b   (nt:folder)
      /caution.png   (nt:file)
                  /jcr:content    (nt:resource)
                              @jcr:data = {contents of the file}
                              @jcr:mimeType = {mime type of the file}
                              @jcr:lastModified = {now}
  </programlisting>
  </para>
  <para>
  When the client uploads the file using the JCR API, DNA gets notified of the changes, consults the sequencers
  to see whether any of them are interested in the new or updated content, and if so runs the sequencers.  The image
  sequencer processes image files for metadata, and any metadata found is stored under the <code>/images</code>
  branch of the repository.
  </para>
  <para>
  So, very soon after the file is uploaded, DNA will sequence the image file and store the metadata.  
  You can search the repository for this metadata using the "s" menu option:
  <figure id="example-sequencer-search">
    <title>Uploading an image using the Example Client</title>
    <graphic align="center" scale="100" fileref="images/example-sequencer-search.png" />
  </figure>
  You can also print the statistics for the sequencer using the "p" menu option:
  <figure id="example-sequencer-statistics">
    <title>Uploading an image using the Example Client</title>
    <graphic align="center" scale="100" fileref="images/example-sequencer-statistics.png" />
  </figure>
  </para>
  <para>
  You can repeat this process with other files.  Any file that isn't an image (as recognized by the sequencing configuration
  described later) will not be sequenced.
  </para>





</chapter>
<chapter id="custom_sequencers">
  <title>Custom sequencers</title>
  <para></para>
</chapter>
<chapter id="future_directions">
  <title>Future directions</title>
  <para>What's next for JBoss DNA?  Well, sequencers are just the beginning.  
  Remember our <link linkend="architecture">architecture</link>?
  There are a lot of components on our roadmap, including federating
  
  </para>
      <para> Roadmap: We'll start on the federation engine as soon as 0.1 is out. The 0.1 release will contain the sequencing
      system, and while there will be one sequencer, we hope the community will help build the ones they need. Serge has started
      on a Java sequencer, and MetaMatrix is starting on a sequencer for MetaMatrix models. Check out JIRA for the list of the
      ones we've thought of.</para>
    <para> Your need for a web UI is very typical, which is why we also want to create a web interface (and RESTful service) that
      presents data using "domain-specific" views - that is, views that are specific to the type of data and user role. For
      example, if a user is viewing database information, the views should be structured to show all the information for a table
      and its columns, keys, and indexes. (This is in contrast with a "generic" node-based view where there is one page that shows
      the table and only links to the other columns, keys, etc. See http://www.jcr-explorer.org/screenshots.html for an example of
      a "generic" web UI.)</para>
</chapter>
</book>