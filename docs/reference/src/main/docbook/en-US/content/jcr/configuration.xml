<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ ModeShape (http://www.modeshape.org)
  ~
  ~ See the COPYRIGHT.txt file distributed with this work for information
  ~ regarding copyright ownership.  Some portions may be licensed
  ~ to Red Hat, Inc. under one or more contributor license agreements.
  ~ See the AUTHORS.txt file in the distribution for a full listing of 
  ~ individual contributors.
  ~
  ~ ModeShape is free software. Unless otherwise indicated, all code in ModeShape
  ~ is licensed to you under the terms of the GNU Lesser General Public License as
  ~ published by the Free Software Foundation; either version 2.1 of
  ~ the License, or (at your option) any later version.
  ~
  ~ ModeShape is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE preface PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"	[
<!ENTITY % CustomDTD SYSTEM "../../custom.dtd">
%CustomDTD;
]>
<chapter id="configuration">
  <title>Configuration</title>
	<para>
		Using ModeShape within your application is actually quite straightforward, and with JCR 2.0 it is possible for your
		application to do everything using only the JCR 2.0 API. Your application will first obtain a <code>javax.jcr.Repository</code> instance,
		and will use that object to create sessions through which your application will read, modify, search,
		or monitor content in the repository.
	</para>
	<para>
		However, before you can use ModeShape, you need to configure it, and that's what this chapter covers.
	</para>
	<sect1 id="jcr_configuration">
		<title>Configuring ModeShape</title>
		<para>
		There really are three options:
		<itemizedlist>
			<listitem>
				<para><emphasis role="strong"><code>Load from a file</code></emphasis> is conceptually the most straightforward and requires the least amount
				of Java code, but it does requires having a configuration file. This is easy, allows one to manage configurations in version control,
				and will likely be the approach most applications use.</para>
			</listitem>
			<listitem>
				<para><emphasis role="strong"><code>Programmatic configuration</code></emphasis> allows an application to define and edit
				a configuration using Java code. This is useful when you cannot pre-define your configuration, or when you want to start
				with a baseline configuration, make programmatic changes based upon some inputs or preferences, and then save
				the configuration to a file.</para>
			</listitem>
			<listitem>
				<para><emphasis role="strong"><code>Load from a configuration repository</code></emphasis> is an advanced technique
				that allows multiple &JcrEngine; instances (usually in different processes perhaps on different machines)
				to easily access a (shared) configuration.</para>
			</listitem>
		</itemizedlist>
	</para>
	<para>
		Each of these approaches has their obvious advantages, so the choice of which one to use is entirely up to you.
	</para>
	<sect2 id="loading_from_file">
		<title>Loading from a Configuration File</title>
		<para>
			Loading the ModeShape configuration from a file is actually very simple:
		</para>
   	<programlisting role="JAVA"><![CDATA[JcrConfiguration config = new JcrConfiguration();
configuration.loadFrom(file);
]]></programlisting>
		<para>
			where the <code>file</code> parameter can actually be a &File; instance, a &URL; to the file, an &InputStream; 
			containing the contents of the file, or even a &String; containing the contents of the file.  
		</para>
		<note>
			<para>The <code>loadFrom(...)</code> method can be called any number of times, but each time it is called it completely wipes
			  out any current notion of the configuration and replaces it with the configuration found in the file.
			</para>
		</note>
		<para>
			There is an optional second parameter that defines the &Path; within the configuration file identifying the parent node of the various
			configuration nodes.  If not specified, it assumes "/".  This makes it possible for the configuration content to be
			located at a different location in the hierarchical structure.  (This is not often required, but when it is required
			this second parameter is very useful.)
		</para>
		<para>
			Here is the configuration file that is used in the repository example, though it has been simplified a bit and most comments 
			have been removed for clarity):
		</para>
   	<programlisting role="XML"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<configuration xmlns:mode="http://www.modeshape.org/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0">
  <!-- 
  Define the JCR repositories 
  -->
  <mode:repositories>
      <!-- 
      Define a JCR repository that accesses the 'Cars' source directly.
      This of course is optional, since we could access the same content through 'vehicles'.
      -->
      <mode:repository jcr:name="car repository" mode:source="Cars">
          <mode:options jcr:primaryType="mode:options">
              <jaasLoginConfigName jcr:primaryType="mode:option" mode:value="modeshape-jcr"/>
          </mode:options>
          <mode:descriptors>
            <!-- 
            	This adds a JCR Repository descriptor named "myDescriptor" with a value of "foo".
            	So this code:
            	Repository repo = ...;
            	System.out.println(repo.getDescriptor("myDescriptor");

            	Will now print out "foo".
            -->
            <myDescriptor mode:value="foo" />
          </mode:descriptors>
          <!-- 
                Import the custom node types defined in the named resource (a file at a 
                classpath-relative path).  If there was more than one file with custom node 
                types, we could either add successive <jcr:nodeTypes ... /> elements or just 
                add all of the files as a comma-delimited string in the mode:resource property.
            -->
          <jcr:nodeTypes mode:resource="/tck/tck_test_types.cnd" />
      </mode:repository>
  </mode:repositories>
   <!-- 
   Define the sources for the content. These sources are directly accessible using the 
   ModeShape-specific Graph API.
   -->
   <mode:sources jcr:primaryType="nt:unstructured">
       <mode:source jcr:name="Cars" 
              mode:classname="org.modeshape.graph.connector.inmemory.InMemoryRepositorySource" 
              mode:retryLimit="3" mode:defaultWorkspaceName="workspace1">
	           <mode:predefinedWorkspaceNames>workspace2</mode:predefinedWorkspaceNames>
	           <mode:predefinedWorkspaceNames>workspace3</mode:predefinedWorkspaceNames>
       </mode:source>
   </mode:sources>
   <!-- 
   Define the sequencers. This is an optional section. For this example, we're not using any sequencers. 
   -->
   <mode:sequencers>
       <!--mode:sequencer jcr:name="Image Sequencer">
           <mode:classname>
           	org.modeshape.sequencer.image.ImageMetadataSequencer
           </mode:classname>
           <mode:description>Image metadata sequencer</mode:description>        
           <mode:pathExpression>/foo/source => /foo/target</mode:pathExpression>
           <mode:pathExpression>/bar/source => /bar/target</mode:pathExpression>
       </mode:sequencer-->
   </mode:sequencers>
   <mode:mimeTypeDetectors>
       <mode:mimeTypeDetector jcr:name="Detector" 
                             mode:description="Standard extension-based MIME type detector"/>
   </mode:mimeTypeDetectors>
</configuration>
]]></programlisting>
	</sect2>
	<sect2 id="programmatic_configuration">
		<title>Programmatic Configuration</title>
		<para>
			Defining the configuration programmatically is not terribly complicated, and it for obvious reasons results in more verbose Java code.
			But this approach is very useful and often the easiest approach when the configuration must change or is a reflection of other
			dynamic information.
		</para>
		<para>
			The &JcrConfiguration; class was designed to have an easy-to-use API that makes it easy to configure each of the different kinds of
			components, especially when using an IDE with code completion.  Here are several examples:
		</para>
		<sect3 id="programmatically_configuring_sources">
			<title>Repository Sources</title>
			<para>Each repository source definition must include the name of the &RepositorySource; class as well as each bean property
				that should be set on the object:
			</para>
   		<programlisting role="JAVA"><![CDATA[JcrConfiguration config = ...
config.repositorySource("source A")
     .usingClass(InMemoryRepositorySource.class)
     .setDescription("The repository for our content")
     .setProperty("defaultWorkspaceName", workspaceName);
]]></programlisting>
			<para>
				This example defines an in-memory source with the name "source A", a description, and a single "defaultWorkspaceName" bean property.
				Different &RepositorySource; implementations will the bean properties that are required and optional.
				Of course, the class can be specified as Class reference or a string (followed by whether the class should be loaded from
				the classpath or from a specific classpath).
			</para>
			<note>
				<para>Each time <code>repositorySource(String)</code> is called, it will either load the existing definition with the supplied
				name or will create a new definition if one does not already exist.  To remove a definition, simply call <code>remove()</code>
				on the result of <code>repositorySource(String)</code>.
				The set of existing definitions can be accessed with the <code>repositorySources()</code> method.
				</para>
			</note>
		</sect3>
		<sect3 id="programmatically_configuring_repositories">
			<title>Repositories</title>
			<para>Each repository must be defined to use a named repository source, but all other aspects (e.g., namespaces, node types, options) 
				are optional.</para> 
   		<programlisting role="JAVA"><![CDATA[JcrConfiguration config = ...
config.repository("repository A")
     .addNodeTypes("myCustomNodeTypes.cnd")
     .setSource("source 1")
     .registerNamespace("acme","http://www.example.com/acme")
     .setOption(JcrRepository.Option.JAAS_LOGIN_CONFIG_NAME, "modeshape-jcr");
]]></programlisting>
			<para>
				This example defines a repository that uses the "source 1" repository source (which could be a federated source, an in-memory source,
				a database store, or any other source).  Additionally, this example adds the node types in the "myCustomNodeTypes.cnd" file as those
				that will be made available when the repository is accessed.  It also defines the "http://www.example.com/acme" namespace,
				and finally sets the "JAAS_LOGIN_CONFIG_NAME" option to define the name	of the JAAS login configuration that should be used by 
				the ModeShape repository.
			</para>
			<note>
				<para>Each time <code>repository(String)</code> is called, it will either load the existing definition with the supplied
				name or will create a new definition if one does not already exist.  To remove a definition, simply call <code>remove()</code>
				on the result of <code>repository(String)</code>.
				The set of existing definitions can be accessed with the <code>repositories()</code> method.
				</para>
			</note>
		</sect3>
		<sect3 id="programmatically_configuring_sequencers">
			<title>Sequencers</title>
			<para>Each defined sequencer must specify the name of the &StreamSequencer; implementation class as well as the path expressions
				defining which nodes should be sequenced and the output paths defining where the sequencer output should be placed (often as a function
				of the input path expression).</para> 
   		<programlisting role="JAVA"><![CDATA[JcrConfiguration config = ...
config.sequencer("Image Sequencer")
     .usingClass("org.modeshape.sequencer.image.ImageMetadataSequencer")
     .loadedFromClasspath()
     .setDescription("Sequences image files to extract the characteristics of the image")
     .sequencingFrom("//(*.(jpg|jpeg|gif|bmp|pcx|png|iff|ras|pbm|pgm|ppm|psd)[*])/jcr:content[@jcr:data]")
     .andOutputtingTo("/images/$1");
]]></programlisting>
			<para>
				This shows an example of a sequencer definition named "Image Sequencer" that uses the &ImageMetadataSequencer; class 
				(loaded from the classpath), that is to sequence the "jcr:data" property on any new or changed nodes that are named 
				"jcr:content" below a parent node	with a name ending in ".jpg", ".jpeg", ".gif", ".bmp", ".pcx", ".iff", ".ras", 
				".pbm", ".pgm", ".ppm" or ".psd".  The output of the sequencing operation should be placed at the "/images/$1" node,
				where the "$1" value is captured as the name of the parent node.  (The capture groups work the same way as regular expressions.)
				Of course, the class can be specified as Class reference or a string (followed by whether the class should be loaded from
				the classpath or from a specific classpath).
			</para>
			<note>
				<para>Each time <code>sequencer(String)</code> is called, it will either load the existing definition with the supplied
				name or will create a new definition if one does not already exist.  To remove a definition, simply call <code>remove()</code>
				on the result of <code>sequencer(String)</code>.
				The set of existing definitions can be accessed with the <code>sequencers()</code> method.
				</para>
			</note>
			<para>Note that in addition to including a description for the configuration, it is also possible to set sequencer-specific properties
				using the <code>setProperty(String,String[])</code> method. When ModeShape uses this configuration to set up a sequencing
				operation, it will instantiate the &StreamSequencer; class and will call a JavaBean-style setter method for each property.
				For example, calling <code>setProperty("foo","val1")</code> on the sequencer configuration will mean that ModeShape
				will instantiate the sequencer implementation and will look for a <code>setFoo(String)</code> method on the sequencer implementation
				class, and use that method (if found) to pass the "val1" value to the instance.
			</para>
		</sect3>
		<sect3 id="programmatically_configuring_mime_type_detectors">
			<title>MIME Type Detectors</title>
			<para>Each defined MIME type detector must specify the name of the &MimeTypeDetector; implementation class as well as any
				other bean properties required by the implementation.</para> 
   		<programlisting role="JAVA"><![CDATA[JcrConfiguration config = ...
config.mimeTypeDetector("Extension Detector")
     .usingClass(org.modeshape.graph.mimetype.ExtensionBasedMimeTypeDetector.class);
]]></programlisting>
			<para>
				Of course, the class can be specified as Class reference or a string (followed by whether the class should be loaded from
				the classpath or from a specific classpath).
			</para>
			<note>
				<para>Each time <code>mimeTypeDetector(String)</code> is called, it will either load the existing definition with the supplied
				name or will create a new definition if one does not already exist.  To remove a definition, simply call <code>remove()</code>
				on the result of <code>mimeTypeDetector(String)</code>.  
				The set of existing definitions can be accessed with the <code>mimeTypeDetectors()</code> method.
				</para>
			</note>
	</sect3>
	<sect3 id="storing_configuration">
		<title>Storing Configuration</title>
		<para>
			Regardless of how the &JcrConfiguration; is loaded, it can also be stored to a file or stream in an XML format that can then be
			reloaded in the future to recreate the configuration. This makes it very easy to programmatically generate a configuration file
			once while being able to load that same configuration at a later time (or on a different instance).
		</para>
   		<programlisting role="JAVA"><![CDATA[JcrConfiguration config = ...
String pathToFile = ...

// Save any changes before this point in the configuration repository ...
configuration.save();
// And now write out the configuration repository to a file ...
configuration.storeTo(pathToFile);
]]></programlisting>
		<para>
			This will create a file at <code>pathToFile</code> that contains the current configuration in XML format. Any changes made after 
			the most recent call to the <code>save()</code> method on the &JcrConfiguration; object will not be saved in the configuration
			repository, and thus will not be in the generated file. The generated XML will not be formatted to maximize human readability.   
		</para>
	</sect3>
	</sect2>
	<sect2 id="loading_from_repository">
		<title>Loading from a Configuration Repository</title>
		<para>
			Loading the ModeShape configuration from an existing repository is also pretty straightforward.  Simply create and configure the
			&RepositorySource; instance to point to the desired repository, and then call the <code>loadFrom(&RepositorySource; source)</code>
			method:
		</para>
   	<programlisting role="JAVA"><![CDATA[RepositorySource configSource = ...
JcrConfiguration config = new JcrConfiguration();
configuration.loadFrom(configSource);
]]></programlisting>
		<para>
			This really is a more advanced way to define your configuration, so we won't go into how you configure a &RepositorySource;.
		</para>
		<note>
			<para>The <code>loadFrom(...)</code> method can be called any number of times, but each time it is called it completely wipes
			  out any current notion of the configuration and replaces it with the configuration found in the file.
			</para>
		</note>
		<para>
			There is an optional second parameter that defines the name of the workspace in the supplied source where the configuration content
			can be found.  It is not needed if the workspace is the source's default workspace. 
			There is an optional third parameter that defines the &Path; within the configuration repository identifying the parent node of the various
			configuration nodes.  If not specified, it assumes "/".  This makes it possible for the configuration content to be
			located at a different location in the hierarchical structure.  (This is not often required, but when it is required
			this second parameter is very useful.)
		</para>
	</sect2>
 </sect1>
	<sect1 id="modeshape_and_jndi">
		<title>Deploying ModeShape via JNDI</title>
		<para>
			Sometimes your applications can simply define a &JcrConfiguration; and instantiate the &JcrEngine; instance directly.
			This is very straightforward, and this is what the <link linkend="downloading_and_running">ModeShape examples</link> do.
		</para>
		<para>
			Web applications are a different story. Often, you may not want your web application to contain the code that initializes
			a ModeShape engine.  Or, you may want the same &JcrEngine; instance to be reused in multiple web applications deployed 
			to the same web/application server. In these cases, it is possible to configure the web/app server's JNDI instance to
			instantiate the &JcrEngine;, meaning the web applications need only use the standard JNDI and JCR APIs.
		</para>
		<sect2 id="modeshape_and_jndi_application">
			<title>Example application using JCR and JNDI</title>
			<para>
				Here's an example of how such a web application would obtain a JCR &Repository; instance, use it to create a &JcrSession;,
				and then close the session when completed.  
			</para>
    	<programlisting role="JAVA"><![CDATA[Session session = null;
try {
  // Look up the JCR Repository object ...
	InitialContext initCtx = new InitialContext();
	Context envCtx = (Context) initCtx.lookup("java:comp/env");
	// name in JNDI is defined by configuration
	Repository repo = (Repository) envCtx.lookup("jcr/local");	

	// Obtain a JCR Session using simple authentication
	// (or use anonymous authentication if desired)
	session = repo.login(new SimpleCredentials("username", "password".toCharArray()));

	// Use the JCR Session to do something interesting

} catch (Exception ex) {
	ex.printStackTrace();
} finally {
	if (session != null) session.logout();
}]]></programlisting>
			<para>
				Note that the location of the &Repository; instance in JNDI depends upon the configuration. In this example, we used
				"<code>jcr/local</code>", but the only requirement is that it match the location where it was placed in JNDI.
			</para>
			<para>
				We showed how web applications can use an existing &Repository; instance. In the next section, we describe how to configure
				the web server so that the &Repository; instance is available in JNDI.
			</para>
		</sect2>
		<sect2 id="modeshape_and_jndi_configuring">
			<title>Configuring JCR and JNDI</title>
			<para>
				Each kind of web server or application server is different, but all servlet containers do provide a way of configuring
				objects and placing them into JNDI.  ModeShape provides a &JndiRepositoryFactory; class that implements &ObjectFactory;
				and that can be used in the server's configuration. The &JndiRepositoryFactory; requires two properties:
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="strong"><code>configFile</code></emphasis> is the path to the 
							<link linkend="loading_from_file">configuration file</link>.  ModeShape will first treat the value of this
							property as a resource name and attempt to load it from the classpath.  If no resource can be found with that name, 
							ModeShape will assume that it is supposed to be a filename (with or without a path) and load it from the filesystem.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="strong"><code>repositoryName</code></emphasis> is the name of a JCR repository that exists
							in the &JcrConfiguration; and that will be made available by this JNDI entry
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Here's an example of a fragment of the <code>conf/context.xml</code> for Tomcat:
			</para>
<programlisting role="XML"><![CDATA[<Resource name="jcr/local" 
          auth="Container"
          type="javax.jcr.Repository"
          factory="org.modeshape.jcr.JndiRepositoryFactory"
          configFile="/resource/path/to/configuration.xml"
          repositoryName="Test Repository Source" />]]></programlisting>
			<para>
				Note that it is possible to have multiple <code>Resource</code> entries. The &JndiRepositoryFactory; ensures
				that only one &JcrEngine; is instantiated, but that a &Repository; instance is registered for each entry.
			</para>
			<para>
				Before the server can start, however, all of the ModeShape jars need to be placed on the classpath for the server.
				JAAS also needs to be configured, and this can be done using the application server's configuration or in your
				web application if you're using a simple servlet container.
			</para>
			<note>
				<para>
					The ModeShape community has solicited input on how we can make it easier to consume and use ModeShape in applications
					that do not use Maven. Check out the <ulink url="http://community.jboss.org/thread/146589">discussion thread</ulink>,
					and please add any suggestions or opinions!
				</para>
			</note>
			<para>
				Then, your web application needs to reference the <code>Resource</code> and state its requirements in its 
				<code>web.xml</code>:
			</para>
<programlisting role="XML"><![CDATA[<resource-env-ref>
   <description>Repository</description>
   <resource-env-ref-name>jcr/local</resource-env-ref-name>
   <resource-env-ref-type>javax.jcr.Repository</resource-env-ref-type>
</resource-env-ref>]]></programlisting>
			<para>
				Note that the value of <code>resource-env-ref-name</code> matches the value of the name attribute on the 
				<code>&lt;Resource></code> tag in the <code>context.xml</code> described above.  This is a must.
			</para>
			<para>
				At this point, your web application can perform the lookup of the &Repository; object, create and use a &Session;,
				and then close the &Session;.  Here's an example of a JSP page that does this:
			</para>
<programlisting role="JAVA"><![CDATA[<%@ page import="
	javax.naming.*,
	javax.jcr.*,
	org.jboss.security.config.IDTrustConfiguration
	" %>
<%!

static {
	// Initialize IDTrust
	String configFile = "security/jaas.conf.xml";
	IDTrustConfiguration idtrustConfig = new IDTrustConfiguration();
	try {
	    idtrustConfig.config(configFile);
	} catch (Exception ex) {
	    throw new IllegalStateException(ex);
	}
}
%>
<%
Session sess = null;
try {
	InitialContext initCtx = new InitialContext();
	Context envCtx = (Context) initCtx.lookup("java:comp/env");
	Repository repo = (Repository) envCtx.lookup("jcr/local");
	sess = repo.login(new SimpleCredentials("readwrite", "readwrite".toCharArray()));

	// Do something interesting with the Session ...
	out.println(sess.getRootNode().getPrimaryNodeType().getName());
} catch (Exception ex) {
	ex.printStackTrace();
} finally {
	if (sess != null) sess.logout();
}
%>
]]></programlisting>			
			<para>
				Since this uses a servlet container, there is no JAAS implementation configured, so note the 
				loading of IDTrust to create the JAAS realm.  (To make this work in Tomcat, the security
				folder that contains the <code>jaas.conf.xml</code>, <code>users.properties</code>, and
				<code>roles.properties</code> needs to be moved into the <code>%CATALINA_HOME%</code> directory.
				Moving the security folder into the <code>conf</code> directory does not allow those files
				to be visible to the JSP page.)
			</para>
			<note>
				<para>
				If you use an application server such as <ulink url="http://www.jboss.com/products/platforms/application/">JBoss EAP</ulink>,
				you could just configure the JAAS realm as part of the server configuration and be done with it.
			  </para>
			</note>
		</sect2>
	</sect1>
	<sect1 id="modeshape_classpath">
		<title>Setting the Classpath</title>
		<para>
			Before you deploy ModeShape into your application or its environment, you need to make sure that all of the ModeShape
			JARs are on the appropriate classpath. Two different scenarios are covered in this section: Maven-based, and using
			JARs with the traditional classpath.
		</para>
		<sect2 id="using_modeshape_via_maven">
			<title>Building against ModeShape via Maven</title>
			<para>
				By far the easiest way to use ModeShape is to use Maven, because with just a few lines of code, Maven will automatically 
				pull all the JARs and source for all of the ModeShape libraries as well as everything those libraries need. 
				All of ModeShape's artifacts for each release are published in the new <ulink url="&JBossMaven;">JBoss Maven repository</ulink> 
				under the "<ulink url="&ModeShapeMaven;">org.modeshape</ulink>" group ID.
			</para>
			<sect3 id="using_jboss_maven_repository">
				<title>Using the JBoss Maven repository</title>
				<para>
					The JBoss Maven repository not only contains all of the artifacts for ModeShape and other open source projects
					hosted at <ulink url="http://www.jboss.org">JBoss.org</ulink>, but it also 
					<ulink url="&JBossMavenDoc;">proxies quite a few other repositories</ulink> that contain many other third-party
					libraries.
				</para>
				<para>
				  So if you're using Maven (or Ivy), first make sure your project knows about this new JBoss Maven repository.
					One way to do this is to add the following to your project POM (you'll still likely want to use other Maven repositories 
					for third-party artifacts):
				</para>
<programlisting role="XML"><![CDATA[<repositories>
  <repository>
    <id>jboss</id>
    <url>http://repository.jboss.org/nexus/content/groups/public/</url>
  </repository>
</repositories>
]]></programlisting>
				<para>
					Or, you can add this information to your <code>~/.m2/settings.xml</code> file. For more information,
					see the <ulink url="&JBossMavenUsing;">JBoss wiki page</ulink>.
				</para>
			</sect3>
			<sect3 id="adding_modeshape_dependencies">
				<title>Add dependency to ModeShape</title>
				<para>
					Then, simply modify your project's POM by adding dependencies on the ModeShape JCR library:
			  </para>
<programlisting role="XML"><![CDATA[<dependency>
  <groupId>org.modeshape</groupId>
  <artifactId>modeshape-jcr</artifactId>
  <version>2.0.0.Final</version>
</dependency>
]]></programlisting>
				<para>
					This adds only the minimal libraries required to use ModeShape, so you need to add dependencies for 
					each of the connectors and sequencers you want to use. Here is the list of available sequencers:
				</para>
<programlisting role="XML"><![CDATA[<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-sequencer-cnd</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-sequencer-ddl</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshapce</groupid>
  <artifactid>modeshape-sequencer-images</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-sequencer-classfile</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-sequencer-java</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-sequencer-mp3</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-sequencer-msoffice</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-sequencer-xml</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-sequencer-text</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-sequencer-zip</artifactid>
  <version>2.0.0.Final</version>
</dependency>
]]></programlisting>
			<para>
				Here is the list of available connectors:
			</para>
<programlisting role="XML"><![CDATA[<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-connector-filesystem</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-connector-infinispan</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-connector-jcr</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-connector-jbosscache</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-connector-jdbc-metadata</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-connector-store-jpa</artifactid>
  <version>2.0.0.Final</version>
</dependency>
<dependency>
  <groupid>org.modeshape</groupid>
  <artifactid>modeshape-connector-svn</artifactid>
  <version>2.0.0.Final</version>
</dependency>]]></programlisting>
	      <para>
		      The sequencer and connector libraries you choose, plus every third-party library they need, will be pulled in automatically 
		      by Maven into your project.
		    </para>
			</sect3>
			<sect3 id="adding_logging_dependencies">
				<title>Add dependencies for logging</title>
				<para>
					ModeShape is designed to use the same logging framework as your application, and it uses SLF4J to accomplish this. 
					In other words, ModeShape depends upon the SLF4J API library, but requires you to provide provide a logging implementation 
					as well as the appropriate SLF4J binding JAR.
				</para>
				<para>
					For example, if your application is using <ulink url="&Log4J;">Log4J</ulink>, your application will already have a dependency 
					for it, and so ModeShape log messages will be sent to the same logging system used in your application, you need to add a 
					dependency to the SLF4J-to-Log4J binding JAR:
				</para>
<programlisting role="XML"><![CDATA[<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-log4j12</artifactId>
  <version>1.5.11</version>
</dependency>
<dependency>
  <groupId>log4j</groupId>
  <artifactId>log4j</artifactId>
  <version>1.2.16</version>
</dependency>
]]></programlisting>
        <para>
	        Of course, SLF4J works with other logging frameworks, too. Some logging implementations (such as <ulink url="&LogBack;">LogBack</ulink>) 
	        implement the SLF4J API natively, meaning they require no binding JAR. For details on the options and how to configure them, see the 
	        <ulink url="&SLF4JManual;">SLF4J manual</ulink>.
        </para>
			</sect3>
		</sect2>
		<sect2 id="using_modeshape_via_jars">
			<title>Building against ModeShape via JARs</title>
			<para>
				If your application doesn't use Maven, you'll need to obtain the ModeShape JARs and place them onto your application's classpath. 
				ModeShape provides a <ulink url="&SingleDownload;">single download</ulink> with all of the JARs for all ModeShape components 
				and all dependencies. This file contains the following:
				<itemizedlist>
	        <listitem>
	          <para>
	            <emphasis role="strong"><code>modeshape-jcr-&versionNumber;-with-dependencies.jar</code></emphasis> contains the JARs 
							necessary to run the core ModeShape JCR repository engine, 
	            the in-memory connector, and the federating connector;
	          </para>
	        </listitem>
	        <listitem>
	          <para>
	            one <emphasis role="strong"><code>modeshape-connector-&lt;type>-&versionNumber;-with-dependencies.jar</code></emphasis> 
							for each type of connector, each containing the JARs necessary 
	            for that connector;
	          </para>
	        </listitem>
	        <listitem>
	          <para>
	            one <emphasis role="strong"><code>modeshape-sequencer-&lt;type>-&versionNumber;-with-dependencies.jar</code></emphasis> 
							for each type of sequencer, each containing the JARs necessary
	            for that sequencer;
	          </para>
	        </listitem>
	        <listitem>
	          <para>
	            <emphasis role="strong"><code>modeshape-mimetype-detector-aperture-&versionNumber;-with-dependencies.jar</code></emphasis> 
							contains all of the JARs required for the component that detects 
	            the MIME type of files based upon names and/or content; and
	          </para>
	        </listitem>
	        <listitem>
	          <para>
	            <emphasis role="strong"><code>modeshape-jpa-ddl-gen-&versionNumber;-jar-with-dependencies.jar</code></emphasis> 
							contains all of the JARs required to run the DDL generation utility.
	          </para>
	        </listitem>
	      </itemizedlist>
				Note that the core engine is required in all configurations. The <code>jcr-2.0.jar</code> file is not included and must be provided by you. 
				And, as mentioned in the <link linkend="adding_logging_dependencies">previous section</link>, ModeShape uses SLF4J for logging and you must provide 
				a logging implementation as well as the appropriate SLF4J binding JAR.
			</para>
		</sect2>
	</sect1>
	<sect1 id="using_modeshape_whats_next">
		<title>What's next</title>
		<para>
			This chapter outlines how you configure ModeShape, how to deploy ModeShape into your application, and how to set up your application's environment
			with the required ModeShape JARs.
			The <link linkend="jcr">next chapter</link> talks about how your application can use the JCR API to access ModeShape repositories.
		</para>
	</sect1>
</chapter>
