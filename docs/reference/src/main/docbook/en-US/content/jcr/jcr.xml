<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ ModeShape (http://www.modeshape.org)
  ~
  ~ See the COPYRIGHT.txt file distributed with this work for information
  ~ regarding copyright ownership.  Some portions may be licensed
  ~ to Red Hat, Inc. under one or more contributor license agreements.
  ~ See the AUTHORS.txt file in the distribution for a full listing of 
  ~ individual contributors.
  ~
  ~ ModeShape is free software. Unless otherwise indicated, all code in ModeShape
  ~ is licensed to you under the terms of the GNU Lesser General Public License as
  ~ published by the Free Software Foundation; either version 2.1 of
  ~ the License, or (at your option) any later version.
  ~
  ~ ModeShape is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE preface PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"	[
<!ENTITY % CustomDTD SYSTEM "../../custom.dtd">
%CustomDTD;
]>
<chapter id="jcr">
  <title>Using the JCR API with ModeShape</title>
  <para>
  	The
    <ulink url="&JSR170;">Content Repository for Java technology API</ulink>
    provides a standard Java API for working with content repositories. Abbreviated "JCR", this API was developed as part of the
    Java Community Process under <ulink url="&JSR170;">JSR-170</ulink> (JCR 1.0) and has been revised under <ulink url="&JSR283;">JSR-283</ulink>.
		ModeShape provides a partial JCR 1.0 implementation that allows you to work with the contents of a repository using the
		JCR API.  For information about how to use the JCR API, please see the <ulink url="&JSR170;">JSR-170</ulink> specification.
	<note>
		<para>In the interests of brevity, this chapter does not attempt to reproduce the JSR-170 specification nor provide
		an exhaustive definition of ModeShape JCR capabilities.  Rather, this chapter will describe any deviations from the
		specification as well as any ModeShape-specific public APIs and configuration.
		</para>
	</note>
  </para>
	<para>Using ModeShape within your application is actually quite straightforward.  As you'll see in this chapter,
		the first step is setting up ModeShape and starting the <code>JcrEngine</code>.  After that, you obtain the
		<code>javax.jcr.Repository</code> instance for a named repository and just use the standard JCR API throughout your
		application.
	</para>
  <sect1>	
    <title>Obtaining JCR Repositories</title>
		<para>Once you've obtained a reference to a <code>JcrEngine</code> as described in 
		<link linkend="configuration">the previous chapter</link>, obtaining a repository is as easy as calling
		the <code>getRepository(String)</code> method with the name of the repository that you just configured.
<programlisting>
&String; repositoryName = ...;
&JcrEngine; jcrEngine = ...;
&Repository; repository = jcrEngine.getRepository(repositoryName);
</programlisting>
			At this point, your application can proceed by working with the JCR API.
		</para>
  </sect1>
  <sect1 id="jcr-sessions">
    <title>Creating JCR Sessions</title>
		<para>Once you have obtained a reference to the JCR &Repository;, you can create a JCR session using one of its
			<code>login(...)</code> methods.  The <ulink url="&JSR170;">JSR-170</ulink> specification provides four login methods, but the
			behavior of these methods depends on the kind of authentication system your application is using.
		</para>
	  <sect2 id="jcr-sessions-jaas">
	    <title>Using JAAS</title>
		<para>The <code>login()</code> method allows the implementation to choose its own security context to create a session in the default workspace
		for the repository.  The ModeShape JCR implementation uses the security context from the current JAAS &AccessControlContext;.  This implies
		that this method will throw a &LoginException; if it is not executed as a &PrivilegedAction; (AND the 
		<code>JcrRepository.Options.ANONYMOUS_USER_ROLES</code> option does not allow access - <link linkend="jcr-guest-access">see below</link> for an example of how to configure guest user access).  
		Here is one example of how this might work:
    <programlisting>
Subject subject = ...;
&Session; session = Subject.doAsPrivileged(subject, new PrivilegedExceptionAction&lt;&Session;&gt;() {
    public Session run() throws Exception {
        return repository.login();
    }
}, AccessController.getContext());
</programlisting>	
		Another variant of this is to use the AccessControlContext directly, which then operates against the current Subject:
    <programlisting>
&Session; session = AccessController.doPrivileged( new PrivilegedExceptionAction&lt;&Session;&gt;() {
    public Session run() throws Exception {
        return repository.login();
    }
});
</programlisting>	
	</para>
	<para>
		Either of these approaches will yield a session with the same user name and roles as <code>subject</code>.  The <code>login(String workspaceName)</code>
		method is comparable and allows the workspace to be specified by name:
    <programlisting>
Subject subject = ...;
final &String; workspaceName = ...;
&Session; session = (&Session;) Subject.doAsPrivileged(subject, new PrivilegedExceptionAction&lt;&Session;&gt;() {
    public Session run() throws Exception {
        return repository.login(workspaceName);
    }}, AccessController.getContext());
</programlisting>	
		</para>
		<para>The JCR API also allows supplying a JCR &Credentials; object directly as part of the login process, although ModeShape imposes
		some requirements on what types of &Credentials; may be supplied.  The simplest way is to provide a JCR &SimpleCredentials; object.
		These credentials will be validated against the JAAS realm named "modeshape-jcr", unless another realm name is provided as an option 
		during the JCR repository configuration.  For example:
	    <programlisting>
&String; userName = ...;
char[] password = ...;
&Session; session = repository.login(new &SimpleCredentials;(userName, password));
</programlisting>	
		Similarly, the <code>login(Credentials credentials, String workspaceName)</code> method enables passing the credentials and a workspace name:
	    <programlisting>
&String; userName = ...;
char[] password = ...;
&String; workspaceName = ...;
&Session; session = repository.login(new &SimpleCredentials;(userName, password), workspaceName);
</programlisting>	
		If a &LoginContext; is available for the user, that can be used as part of the credentials to authenticate the user with
		ModeShape instead.  This snippet uses an anonymous class to provide the login context, but any class with a <code>&LoginContext; getLoginContext()</code>
		method can be used as well.
	    <programlisting>
final &LoginContext; loginContext = ...;
&Session; session = repository.login(new &Credentials;() {
	&LoginContext; loginContext getLoginContext() {
		return loginContext;
	}
}, workspaceName);
</programlisting>
      </para>
	  </sect2>
		<sect2 id="jcr-sessions-custom">
  		<title>Using Custom Security</title>
			<para>
		Not all applications can or want to use JAAS for their authentication system, so ModeShape provides a way to integrate your own custom
		security provider.  The first step is to provide a custom implementation of &SecurityContext; that integrates with your application security, allowing
		ModeShape to discover the authenticated user's name, determine whether the authenticated user has been assigned particular roles
		(see the <link linkend="modeshape_jcr_security">JCR Security section</link>), and to notify your application security system that the
		authenticated session (for JCR) has ended.
		</para>
		<para>
			The next step is to wrap your &SecurityContext; instance within an instance of &SecurityContextCredentials;, and pass it as the Credentials
			parameter in one of the two <code>login(...)</code> methods:
			<programlisting>
&SecurityContext; securityContext = new CustomSecurityContext(...);
&Session; session = repository.login(new &SecurityContextCredentials;(securityContext));
			</programlisting>			
      Once the &Session; is obtained, the repository content can be accessed and modified like any other JCR repository.
		</para>
	</sect2>
		<sect2 id="jcr-sessions-servlet">
  		<title>Using HTTP Servlet security</title>
			<para>
		Servlet-based applications can make use of the servlet's existing authentication mechanism from &HttpServletRequest;.  Please note that 
		the example below assumes that the servlet has a security constraint that prevents unauthenticated access.
	    <programlisting>
&HttpServletRequest; request = ...;
&SecurityContext; securityContext = new &ServletSecurityContext;(request);
&Session; session = repository.login(new &SecurityContextCredentials;(securityContext));
</programlisting>
    You'll note that this is just a specialization of the <link linkend="jcr-sessions-custom">custom security context</link> approach, since
    the &ServletSecurityContext; just implements the &SecurityContext; interface and delegates to the &HttpServletRequest;.  Feel free to use
    this class in your servlet-based applications.
		</para>
	</sect2>
		<sect2 id="jcr-guest-access">
  		<title>Guest (Anonymous) User Access</title>
			<para>
		By default, ModeShape allows guest users full administrative access.  This is done to make it easier to get started with ModeShape.  Of course,
		this is clearly not an appropriate security model for a production system.  
		</para>
		<para>
		To modify the roles granted to guest users, change
		the <code>JcrRepository.Options.ANONYMOUS_USER_ROLES</code> option for your repository to have a different value, like &quot;&quot; (to disable
		guest access entirely) or &quot;readonly&quot; (to give guests read-only access to all repositories).  The value of this option can
		be any pattern that matches those described in the <link linkend="role-formats">table below</link>.  
		<note>
			<para>
				The Using ModeShape chapter of the Getting Started Guide provides examples of modifying this option through programmatic configuration or
				in an XML configuration file.
			</para>
		</note>
		</para>
	</sect2>
	</sect1>
	<sect1 id="jcr-spec-support">
		<title>JCR Specification Support</title>
		<para>
		We believe that ModeShape JCR implementation is JCR-compliant, but we are awaiting final certification of compliance.
		Additionally, the JCR 
		specification allows some latitude to implementors for some implementation details.  The sections below
		clarify ModeShape's current and planned behavior.  <emphasis>As always, please consult the 
		<ulink url="&Roadmap;">current list of known issues and bugs</ulink>.</emphasis>
		</para> 
		<sect2>
			<title>Level 1 and Level 2 (Required) Features</title>
			<para>
				ModeShape currently supports all Level 1 and Level 2 features defined by the 
				<ulink url="&JSR170;">JSR-170</ulink> specification.
			</para>
		</sect2>
		<sect2>
			<title>Optional Features</title>
			<para>
				ModeShape also supports the optional JCR locking, observation, and versioning features, 
				though the ModeShape behavior with regard to events upon deletion follows the updated behavior 
				outline in the <ulink url="&JSR283;">JSR-283</ulink> specification (namely that when a subgraph 
				is deleted, ModeShape generates only one event for the top-level node in that subgraph).
			</para>
			<para>
				ModeShape does not support the optional SQL query feature as defined by <ulink url="&JSR170;">JSR-170</ulink>
				and the JCR-SQL query language.
				Instead, ModeShape already supports its replacement, the <emphasis>JCR-SQL2</emphasis> query language defined by the 
				<ulink url="&JSR283;">JSR-283</ulink> specification.  JCR-SQL2 is much improved and much more capable.
				For details, see the chapter on <link linkend="jcr-query-and-search">queries and search languages</link>.
			</para>
		</sect2>
		<sect2 id="modeshape_jcr_security">
			<title>JCR Security</title>
			<para>
				Although the <ulink url="&JSR170;">JSR-170</ulink> specification requires implementation of the <code>Session.checkPermission(String, String)</code> method,
				it allows implementors to choose the granularity of their access controls.  ModeShape supports coarse-grained, role-based access control at the repository 
				and workspace level.
			</para>
			<para>
				ModeShape has extended the set of JCR-defined actions ("add_node", "set_property", "remove", and "read") with additional actions ("register_type",  
				"register_namespace", and "unlock_any").  The register_type and register_namespace permissions restrict the ability to register (and unregister) node types and namespaces, respectively.
				The unlock_any permission grants the user the ability to unlock any locked node or branch (as opposed to users without that permission who can only unlock nodes or branches that they 
				have locked themselves or for which they hold the lock token).  
				Permissions to perform these actions are aggregated in roles that can be assigned to users. 
			</para>
			<para>
				ModeShape currently defines three roles: <code>readonly</code>, <code>readwrite</code>, and <code>admin</code>.  If the &Credentials; passed into 
				<code>Repository.login(...)</code> (or the &Subject; from the &AccessControlContext;, if one of the no-credential <code>login</code> methods were used) have any of these roles, 
				the session will have the corresponding access to all workspaces within the repository.  The mapping from the roles to the actions that they allow is provided below,
				for any values of <code>path</code>.  
				  
				<table frame='all'>
		<title>Role / Action Mapping</title>
		<tgroup cols='4' align='left' colsep='1' rowsep='1'>
      <colspec colname='c1' colwidth="1*"/>
      <colspec colname='c2' colwidth="1*"/>
      <colspec colname='c3' colwidth="1*"/>
      <colspec colname='c4' colwidth="1*"/>
			<thead>
				<row>
		  		<entry>Action Name</entry>
		  		<entry>readonly</entry>
		  		<entry>readwrite</entry>
		  		<entry>admin</entry>
				</row>
			</thead>
			<tbody>
				<row>
					<entry>read</entry>
					<entry>Allows</entry>
					<entry>Allows</entry>
					<entry>Allows</entry>
				</row>
				<row>
					<entry>add_node</entry>
					<entry></entry>
					<entry>Allows</entry>
					<entry>Allows</entry>
				</row>
				<row>
					<entry>set_property</entry>
					<entry></entry>
					<entry>Allows</entry>
					<entry>Allows</entry>
				</row>
				<row>
					<entry>remove</entry>
					<entry></entry>
					<entry>Allows</entry>
					<entry>Allows</entry>
				</row>
				<row>
					<entry>register_namespace</entry>
					<entry></entry>
					<entry></entry>
					<entry>Allows</entry>
				</row>
				<row>
					<entry>register_type</entry>
					<entry></entry>
					<entry></entry>
					<entry>Allows</entry>
				</row>
				<row>
					<entry>unlock_any</entry>
					<entry></entry>
					<entry></entry>
					<entry>Allows</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
				  
				<note>
					<para> In this release, ModeShape does not check that the <code>actions</code> parameter passed into 
						<code>Session.checkPermission(...)</code> contains only valid actions. This check may be added in a future release.
					</para>
				</note> 
				
				It is also possible to grant access only to one or more repositories on a single ModeShape server or to one or more named workspaces within a repository.  The format for 
				role names is defined below:
			</para>
				<table frame='all' id="role-formats">
		<title>Role Formats</title>
		<tgroup cols='3' align='left' colsep='1' rowsep='1'>
			<thead>
				<row>
		  		<entry>Role Pattern</entry>
		  		<entry>Examples</entry>
		  		<entry>Description</entry>
				</row>
			</thead>
			<tbody>
				<row>
					<entry>ROLE_NAME</entry>
					<entry><code>readonly</code>, <code>admin</code></entry>
					<entry>Grants the named role to the assigned user on every workspace in any repository on the ModeShape server.</entry>
				</row>
				<row>
					<entry>ROLE_NAME.REPOSITORY_NAME</entry>
					<entry><code>readonly.modeshape_repo</code>, <code>admin.localRepository</code></entry>
					<entry>Grants the named role to the assigned user on every workspace in the named repository on the ModeShape server.</entry>
				</row>
				<row>
					<entry>ROLE_NAME.REPOSITORY_NAME.WORKSPACE_NAME</entry>
					<entry><code>readonly.modeshape_repo.jsmith</code>, <code>admin.localRepository.default</code></entry>
					<entry>Grants the named role to the assigned user on the named workspace in the named repository on the ModeShape server.</entry>
				</row>
			</tbody>
		</tgroup>
	</table>			
			<para>
				It is also possible to grant more than one role to the same user.  For example, the user jsmith could be granted the roles readonly.production, readwrite.production.jsmith,
				and readwrite.staging to allow read-only access to any workspace on a production repository, read/write access to a personal workspace on the same production repository,
				and read/write access to any workspace in a staging repository.    
			</para>
			<para>
				As a final note, the ModeShape JCR implementation may have additional security roles added prior to the 1.0 release.  A <code>CONNECT</code> role
				is already being used by the ModeShape REST Server to control whether users have access to the repository through that means.   
			</para>
		</sect2>
		<sect2>
			<title>Built-In Node Types</title>
			<para>ModeShape supports all of the built-in node types described in the JSR-170 specification.
			ModeShape also defines some custom node types in the <code>mode</code> namespace, but none of these
			node types except for <code>mode:resource</code> are intended to be used by developers integrating with ModeShape and may be changed or removed
			at any time.
			</para>
		</sect2>
		<sect2>
			<title>Custom Node Type Registration</title>
			<para>
				Although the <ulink url="&JSR170;">JSR-170</ulink> specification does not require support for registration and unregistration of custom types, ModeShape supports this extremely
				useful feature.  Custom node types can be added at startup, as noted above or at runtime through a ModeShape-specific interface.  ModeShape supports defining node
				types either through a <ulink url="&JSR283;">JSR-283</ulink>-like template approach or through the use of &CND; (CND) files.
				Both type registration mechanisms are supported equally within ModeShape, although the CND approach for defining node types is recommended.
				<note>
					<para>ModeShape also supports defining custom node types to load at startup.  This is discussed in more detail
					in the <link linkend="programmatically_configuring_repositories">previous chapter</link>.
					</para>
				</note>
			</para>
			<para>
				The JSR-283 specification provides a useful means of programmatically defining JCR node types.  ModeShape supports a comparable
				node type definition API that implements the functionality from the specification, albeit with interfaces in the <code>org.modeshape.jcr.nodetype</code> package.  
				The intent is to deprecate these classes and replace their usage with the JSR-283 equivalents when ModeShape fully supports
				the JSR-283 final adopted specification in a future release.
			</para>
			<para>
				Node types can be defined like so:
	    <programlisting>
&Session; session = ... ;
&Workspace; workspace = session.getWorkspace();

// Obtain the ModeShape-specific node type manager ...
&JcrNodeTypeManager; nodeTypeManager = (JcrNodeTypeManager) workspace.getNodeTypeManager();

// Declare a mixin node type named "searchable" (with no namespace)
&NodeTypeTemplate; nodeType = nodeTypeManager.createNodeTypeTemplate();
nodeType.setName("searchable");
nodeType.setMixin(true);

// Add a mandatory child named "source" with a required primary type of "nt:file" 
&NodeDefinitionTemplate; childNode = nodeTypeManager.createNodeDefinitionTemplate();
childNode.setName("source");
childNode.setMandatory(true);
childNode.setRequiredPrimaryTypes(new String[] { "nt:file" });
childNode.setDefaultPrimaryType("nt:file");
nodeType.getNodeDefinitionTemplates().add(childNode);

// Add a multi-valued STRING property named "keywords"
&PropertyDefinitionTemplate; property = nodeTypeManager.createPropertyDefinitionTemplate();
property.setName("keywords");
property.setMultiple(true);
property.setRequiredType(PropertyType.STRING);
nodeType.getPropertyDefinitionTemplates().add(property);

// Register the custom node type
nodeTypeManager.registerNodeType(nodeType,false);
</programlisting>	
			Residual properties and child node definitions can also be defined simply by not calling <code>setName</code> on 
			the template.
			</para>
			<para>
			Custom node types can be defined more succinctly through the &CND; file format.  In fact, this is how JBoss
			ModeShape defines its built-in node types. An example CND file that declares the same node type as above would be:
<programlisting>
[searchable] mixin
- keywords (string) multiple
+ source (nt:file) = nt:file
</programlisting>	
			This definition could then be registered as part of the repository configuration, using the &JcrConfiguration; class
			(see the <link linkend="programmatically_configuring_repositories">previous chapter</link>).  Or, you can also
			use a Session to declare the node types in a CDN file, but this also requires ModeShape-specific interfaces and classes:
<programlisting>
String pathToCndFileInClassLoader = ...;
&CndNodeTypeSource; nodeTypeSource = new &CndNodeTypeSource;(pathToCndFileInClassLoader);

for (&Problem; problem : nodeTypeSource.getProblems()) {
    System.err.println(problem);
}
if (!nodeTypeSource.isValid()) {
    throw new IllegalStateException("Problems loading node types");
}

&Session; session = ... ;
// Obtain the ModeShape-specific node type manager ...
&Workspace; workspace = session.getWorkspace();
&JcrNodeTypeManager; nodeTypeManager = (JcrNodeTypeManager) workspace.getNodeTypeManager();
nodeTypeManager.registerNodeTypes(nodeTypeSource);
</programlisting>

    The &CndNodeTypeSource; class actually implements the &JcrNodeTypeSource; interface, so other implementations can actually be defined.
    For more information, see the JavaDoc for &JcrNodeTypeSource;.
			</para>
			<para> 
				ModeShape also supports a simple means of unregistering types, although it is not possible to unregister types that are
				currently being used by nodes or as required primary types or supertypes of other types.  Unused node types can be unregistered 
				with the following code:
<programlisting>
String unusedNodeTypeName = ...;

&Session; session = ... ;
// Obtain the ModeShape-specific node type manager ...
&Workspace; workspace = session.getWorkspace();
&JcrNodeTypeManager; nodeTypeManager = (JcrNodeTypeManager) workspace.getNodeTypeManager();
nodeTypeManager.unregisterNodeType(Collections.singleton(unusedNodeTypeName));
</programlisting>
				
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Summary</title>
		<para>
			In this chapter, we covered how to use JCR with ModeShape and learned about how it implements the JCR specification.  
			Now that you know how ModeShape repositories work and how to use JCR to work with ModeShape repositories, we'll move on in 
			the <link linkend="jcr-query-and-search">next chapter</link> to show how you can use ModeShape to query and search your JCR data.
		</para>
	</sect1>
</chapter>
