<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ JBoss DNA (http://www.jboss.org/dna)
  ~
  ~ See the COPYRIGHT.txt file distributed with this work for information
  ~ regarding copyright ownership.  Some portions may be licensed
  ~ to Red Hat, Inc. under one or more contributor license agreements.
  ~ See the AUTHORS.txt file in the distribution for a full listing of 
  ~ individual contributors.
  ~
  ~ JBoss DNA is free software. Unless otherwise indicated, all code in JBoss DNA
  ~ is licensed to you under the terms of the GNU Lesser General Public License as
  ~ published by the Free Software Foundation; either version 2.1 of
  ~ the License, or (at your option) any later version.
  ~
  ~ JBoss DNA is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE preface PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"	[
<!ENTITY % CustomDTD SYSTEM "../custom.dtd">
%CustomDTD;
]>
<chapter id="introduction">
  <title>Introduction to JBoss DNA</title>
	<para>
		The JBoss DNA project is building a unified metadata repository system that is <link linkend="jcr_intro">JCR-compliant</link>
		and capable of federating information from a variety of back-end systems.  To client applications, JBoss DNA looks and behaves like a 
		regular JCR repository that they search, navigate, version, and listen for changes.  But under the covers, JBoss DNA
		gets its content by federating multiple back-end systems (like databases, services, other repositories, etc.),
		allowing those systems to continue "owning" the information while ensuring the unified repository stays up-to-date
		and in sync.  JBoss DNA also analyzes the files you upload into the repository and turns it into information you can use more effectively.
	</para>
	<para>
		This document goes into detail about JBoss DNA and its capabilities, features, architecture, components, extension points,
		security, configuration, and the development environment and procedures.  
		So whether your a developer on the project, or you're trying to learn the intricate details of
		how JBoss DNA works, this document hopefully serves a good reference for developers on the project.
	</para>
	<sect1 id="use_cases">
		<title>Use cases for JBoss DNA</title>
		<para>
			JBoss DNA repositories can be used in a variety of applications.  One of the more obvious use cases for a metadata repository
			is in provisioning and management, where it's critical to understand and keep track of the metadata for models, database, services, 
			components, applications, clusters, machines, and other systems used in an enterprise.  Governance takes that a step 
			farther, by also tracking the policies and expectations against which performance of the systems described by the repository can be verified.
			In these cases, a repository is an excellent mechanism for managing this complex and highly-varied information.
		</para>
		<para>
			But these large and complex use cases aren't the only way to use a JBoss DNA repository.  You could use an embedded JBoss DNA repository
			to manage configuration information for an application, or you could use JBoss DNA just provide a JCR interface on top of a few non-JCR systems.
		</para>
		<para>
			The point is that JBoss DNA can be used in many different ways, ranging from the very tiny embedded repository to a large and distributed
			enterprise-grade repository.  The choice is yours.
		</para>
	</sect1>
	<sect1 id="what_is_metadata">
		<title>What is metadata?</title>
		<para>
		Before we dive into more detail about JBoss DNA and metadata repositories, it's probably useful to explain what we
		mean by the term "metadata."  Simply put, <emphasis>metadata</emphasis> is the information you need to manage something.  
		For example, it's the information needed to configure an operating system, or the description of the information in an LDAP tree, 
		or the topology of your network. It's the configuration of an application server or enterprise service bus.
		It's the steps involved in validating an application before it can go into production. It's the description of your 
		database schemas, or of your services, or of the messages going in and coming out of a service. JBoss DNA is 
		designed to be a repository for all this (and more).
		</para>
		<para>
		There are a couple of important things to understand about metadata.  First, many systems manage (and frequently change) their own metadata and information.
		Databases, applications, file systems, source code management systems, services, content management systems, and even other repositories 
		are just a few types of systems that do this. We can't pull the information out and duplicate it, because
		then we risk having multiple copies that are out-of-sync.  Ideally, we could access all of this information through a homogenous API
		that also provides navigation, caching, versioning, search, and notification of changes.  That would make our lives significantly easier.
		</para>
		<para>
		What we want is <emphasis><link linkend="dna-connector-federation">federation</link></emphasis>.
		We can connect to these back-end systems to dynamically access the content and project it into a single, unified
		repository.  We can also cache it for faster access, as long as the cache can be invalidated based upon time or event.
		But we also need to maintain a clear picture of where all the bits come from, so users can be sure they're looking
		at the right information.  And we need to make it as easy as possible to write new connectors, since there are
		a lot of systems out there that have information we want to federate.
		</para>
		<para>
		The second important characteristic of the metadata is that a lot of it is represented as files, and there are
		a lot of different file formats.  These include source code, configuration files, web pages, database schemas,
		XML schemas, service definitions, policies, documents, spreadsheets, presentations, images, audio files, workflow
		definitions, business rules, and on and on.  And logically if files contain metadata, we want to add those files
		to our metadata repository.  The problem is, all that metadata is tied up as blobs in the repository.
		Ideally, our repository would automatically extract from those files the content that's most useful to us,
		and place that content inside the repository where it can be much more easily used, searched, related, and analyzed.
		JBoss DNA does exactly this via a process we call <emphasis><link linkend="sequencing">sequencing</link></emphasis>,
		and it's an important part of a metadata repository.
		</para>
		<para>
		The third important characteristic of metadata is that it rarely stays the same.  Different consumers of the
		information need to see different views of it.  Metadata about two similar systems is not always the same.
		The metadata often needs to be tagged or annotated with additional information.  And the things being
		described often change over time, meaning the metadata has to change, too.  As a result, the way in which
		we store and manage the metadata has to be flexible and able to adapt to our ever-changing needs, and the object model
		we use to interact with the repository must accommodate these needs.  The graph-based nature of the JCR API provides this 
		flexibility while also giving us the ability to constrain information when it needs to be constrained.
		</para>
	</sect1>
  <sect1 id="jcr_intro">
    <title>What is JCR?</title>
	  <para>There are a lot of choices for how applications can store information persistently so that it can be accessed at a
	    later time and by other processes. The challenge developers face is how to use an approach that most closely matches the
	    needs of their application. This choice becomes more important as developers choose to focus their efforts on
	    application-specific logic, delegating much of the responsibilities for persistence to libraries and frameworks.</para>
	  <para>
	    Perhaps one of the easiest techniques is to simply store information in
	    <emphasis>files</emphasis>
	    . The Java language makes working with files relatively easy, but Java really doesn't provide many bells and whistles. So
	    using files is an easy choice when the information is either not complicated (for example property files), or when users may
	    need to read or change the information outside of the application (for example log files or configuration files). But using
	    files to persist information becomes more difficult as the information becomes more complex, as the volume of it increases,
	    or if it needs to be accessed by multiple processes. For these situations, other techniques often have more benefits.
	  </para>
	  <para>
	    Another technique built into the Java language is
	    <emphasis>Java serialization</emphasis>
	    , which is capable of persisting the state of an object graph so that it can be read back in at a later time. However, Java
	    serialization can quickly become tricky if the classes are changed, and so it's beneficial usually when the information is
	    persisted for a very short period of time. For example, serialization is sometimes used to send an object graph from one
	    process to another.  Using serialization for longer-term storage of information is more risky.
	  </para>
	  <para>
	    One of the more popular and widely-used persistence technologies is the <emphasis>relational database</emphasis>. 
			Relational database management systems have been around for decades and are very capable. The Java Database Connectivity
	    (JDBC) API provides a standard interface for connecting to and interacting with relational databases. However, it is a
	    low-level API that requires a lot of code to use correctly, and it still doesn't abstract away the DBMS-specific SQL
	    grammar. Also, working with relational data in an object-oriented language can feel somewhat unnatural, so many developers
	    map this data to classes that fit much more cleanly into their application. The problem is that manually creating this
	    mapping layer requires a lot of repetitive and non-trivial JDBC code.
	  </para>
	  <para>
	    <emphasis>Object-relational mapping</emphasis>
	    libraries automate the creation of this mapping layer and result in far less code that is much more maintainable with
	    performance that is often as good as (if not better than) handwritten JDBC code. The new
	    <ulink url="http://java.sun.com/developer/technicalArticles/J2EE/jpa/">Java Persistence API (JPA)</ulink>
	    provide a standard mechanism for defining the mappings (through annotations) and working with these entity objects. Several
	    commercial and open-source libraries implement JPA, and some even offer additional capabilities and features that go beyond
	    JPA. For example, <ulink url="http://www.hibernate.org">Hibernate</ulink> is one of the most feature-rich JPA implementations
			and offers object caching, statement caching, extra association
	    mappings, and other features that help to improve performance and usefulness.  Plus, Hibernate is open-source (with support
			offered by <ulink url="http://www.jboss.com">JBoss</ulink>).
	  </para>
	  <para>
	    While relational databases and JPA are solutions that work well for many applications, they are more limited in cases when the
	    information structure is highly flexible, the structure is not known <emphasis>a priori</emphasis>, or that structure is
	 		subject to frequent change and customization. In these situations, <emphasis>content repositories</emphasis>
	    may offer a better choice for persistence. Content repositories are almost a hybrid with the storage capabilities of
	 		relational databases and the flexibility offered by other systems, such as using files.  Content repositories also
	    typically provide other capabilities as well, including versioning, indexing, search, access control,
	    transactions, and observation. Because of this, content repositories are used by content management systems (CMS), document
	    management systems (DMS), and other applications that manage electronic files (e.g., documents, images, multi-media, web
	    content, etc.) and metadata associated with them (e.g., author, date, status, security information, etc.). The
	    <ulink url="http://www.jcp.org/en/jsr/detail?id=170">Content Repository for Java technology API</ulink>
	    provides a standard Java API for working with content repositories. Abbreviated "JCR", this API was developed as part of the
	    Java Community Process under <ulink url="http://www.jcp.org/en/jsr/detail?id=170">JSR-170</ulink>
	    and is being revised under <ulink url="http://www.jcp.org/en/jsr/detail?id=283">JSR-283</ulink>.
	  </para>
	  <para>
	    The <emphasis>JBoss DNA project</emphasis>
	    is building unified metadata repository system that will be compliant with JCR.  Nearly all of these capabilities are to be hidden
	    below the JCR API and involve automated processing of the information in the repository. Thus, JBoss DNA can add value to
	    existing repository implementations. For example, JCR repositories offer the ability to upload files into the repository and
	    have the file content indexed for search purposes. JBoss DNA also defines a library for "sequencing" content - to extract
	    meaningful information from that content and store it in the repository, where it can then be searched, accessed, and
	    analyzed using the JCR API.
	  </para>
	  <para> JBoss DNA has other features as well.  You can create federated repositories that dynamically merge the information 
		  from multiple databases, services, applications, and other JCR repositories.  JBoss DNA also will allow you to 
	    create customized views based upon the type of data and the role of the user that is accessing the data. And yet another goal is
	    to create a REST-ful API to allow the JCR content to be accessed easily by other applications written in other languages.
	  </para>
	</sect1>
  <sect1 id="roadmap">
    <title>Project roadmap</title>
    <para>
      The roadmap for JBoss DNA is managed in the project's
      <ulink url="&JIRA;">JIRA instance</ulink>
      . The roadmap shows the different tasks, requirements, issues and other activities that have been targeted to each of the
      upcoming releases. (The
      <ulink url="&JIRA;?report=com.atlassian.jira.plugin.system.project:roadmap-panel">roadmap report</ulink>
      always shows the next three releases.)
    </para>
    <para>
      By convention, the JBoss DNA project team periodically review JIRA issues that aren't targeted to a release, and then schedule
 			them based upon current workload, severity, and the roadmap.  And if we review an issue and don't know how to target it,
			we target it to the
      <ulink url="&JIRA;?report=com.atlassian.jira.plugin.system.project:roadmap-panel">Future Releases</ulink>
      bucket.
		</para>
		<para>
			At the start of a release, the project team reviews the roadmap, identifies the goals for the release, and targets (or retargets)
			the issues appropriately.
    </para>
  </sect1>
  <sect1 id="methodology">
    <title>Development methodology</title>
    <para>
			Rather than use a single formal development methodology, the JBoss DNA project incorporates those techniques, activities, and 
			processes that are practical and work for the project. In fact, the committers are given a lot of freedom for how they develop 
			the components and features they work on.
		</para>
		<para>
			Nevertheless, we do encourage familiarity with several major techniques, including:
			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="strong"><ulink url="&Wikipedia;Agile_software_development">Agile software development</ulink></emphasis>
					  includes those software methodologies (e.g., Scrum) that promote development iterations and open collaboration.  While the
						JBoss DNA project doesn't follow these closely, we do emphasize the importance of always having running software
						and using running software as a measure of progress.  The JBoss DNA project also wants to move to more frequent
						releases (on the order of 4-6 weeks)
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis role="strong"><ulink url="&Wikipedia;Test-driven_development">Test-driven development (TDD)</ulink></emphasis>
						techniques encourage first writing test cases for new features and functionality, then changing the code to add the
						new features and functionality, and finally the code is refactored to clean-up and address any duplication or inconsistencies.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis role="strong"><ulink url="http://behaviour-driven.org/">Behavior-driven development (BDD)</ulink></emphasis>
						is an evolution of TDD, where developers specify the desired behaviors first (rather than writing "tests").
						In reality, this BDD adopts the language of the user so that tests are written using words that are meaningful
						to users.  With recent test frameworks (like JUnit 4.4), we're able to write our unit tests to express
						the desired behavior.  For example, a test class for sequencer implementation might have a test method
						<code>shouldNotThrowAnErrorWhenStreamIsNull()</code>, which is very easy to understand the intent.
						The result appears to be a larger number of finer-grained test methods, but which are more easily understood
						and easier to write.  In fact, many advocates of BDD argue that one of the biggest challenges of TDD is knowing what
						tests to write in the beginning, whereas with BDD the shift in focus and terminology make it easier for more
						developers to enumerate the tests they need.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis role="strong"><ulink url="&Wikipedia;Lean_software_development">Lean software development</ulink></emphasis>
						is an adaptation of <ulink url="&Wikipedia;Lean_manufacturing">lean manufacturing techniques</ulink>,
						where emphasis is placed on eliminating waste (e.g., defects, unnecessary complexity, unnecessary code/functionality/features), 
						delivering as fast as possible, deferring irrevocable decisions as much as possible,
						continuous learning (continuously adapting and improving the process), empowering the team (or community, in our case),
						and several other guidelines.  Lean software development can be thought of as an evolution of agile techniques
						in the same way that behavior-driven development is an evolution of test-driven development.  Lean techniques
						help the developer to recognize and understand how and why features, bugs, and even their processes impact the development
						of software.
					</para>
				</listitem>
			</itemizedlist>
    </para>
  </sect1>
  <sect1 id="modules">
    <title>JBoss DNA modules</title>
    <para>
      JBoss DNA consists of the following modules:
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="strong">dna-common</emphasis>
            is a low-level library of common utilities and frameworks, including logging, progress monitoring,
            internationalization/localization, text translators, component management, and class loader factories.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-graph</emphasis>
            defines the graph Application Programming Interface (API) and Service Provider Interface (SPI) for DNA, 
						including the repository connectors, sequencers, graph interfaces, and MIME type detectors.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-repository</emphasis>
            is the main module and provides the repository-oriented services, including the Repository Service, Sequencing
            Service, Observation Service, and Rules Service.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-cnd</emphasis>
            provides a utilities for reading and writing files in the CND (Compact Node Definition) format.
          </para>
        </listitem>        
        <listitem>
          <para>
            <emphasis role="strong">dna-jcr</emphasis>
            provides the JBoss DNA implementation of the JCR API, which relies upon a repository connector, such as the
            Federation Connector (see
            <code>dna-connector-federation</code>
            ).  As DNA does not fully implement the JCR 1.0.1 specification, there are a series of tests that are currently commented 
            out in this module.  The <code>dna-jcr-tck</code> module contains all of these tests.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-jcr-tck</emphasis>
            provides a separate testing project that executes all JackRabbit JCR TCK tests on a nightly basis to track implementation
            progress against the JCR 1.0 specification.  This module will likely be retired when the <code>dna-jcr</code> implementation
            is complete.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-integration-tests</emphasis>
            provides a home for all of the integration tests that involve more components that just unit tests. Integration
            tests are often more complicated, take longer, and involve testing the integration and functionality of many
            components (whereas unit tests focus on testing a single class or component and may use stubs or mock objects for
            other components).
          </para>
        </listitem>
      </itemizedlist>
      The following modules are optional extensions that may be used selectively and as needed (and are located in the source
      under the
      <code>extensions/</code>
      directory):
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="strong">dna-classloader-maven</emphasis>
            is a small library that provides a
            <code>ClassLoaderFactory</code>
            implementation that can create
            <code>java.lang.ClassLoader</code>
            instances capable of loading classes given a Maven Repository and a list of Maven coordinates. The Maven Repository
            can be managed within a JCR repository.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-common-jdbc</emphasis>
            contains several helpful utility classes for interacting with JDBC connections.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-connector-federation</emphasis>
            is a DNA repository connector that federates, integrates and caches information from multiple sources (via other
            repository connectors).
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-connector-filesystem</emphasis>
            is a DNA repository connector that provides read-only access to file systems, allowing their structure and data to be 
            viewed as repository content.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-connector-jdbc-metadata</emphasis>
            is a prototype DNA repository connector that provides read-only access to metadata from relational databases through a JDBC 
            connection.
                        <emphasis>This is still under development.</emphasis>
          </para>
        </listitem>        
        <listitem>
          <para>
            <emphasis role="strong">dna-connector-jbosscache</emphasis>
            is a DNA repository connector that manages content within a
            <ulink url="http://www.jboss.org/jbosscache/">JBoss Cache</ulink>
            instance. JBoss Cache is a powerful cache implementation that can serve as a distributed cache and that can persist
            information. The cache instance can be found via JNDI or created and managed by the connector.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-connector-store-jpa</emphasis>
            is a DNA sequencer that provides for persistent storage and access of DNA content in a relational database.  This connector
            is based on JPA technology.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-connector-svn</emphasis>
            is a prototype DNA sequencer that obtains content from a Subversion repository, providing that content in
						the form of <code>nt:file</code> and <code>nt:folder</code> nodes.
						<emphasis>This is still under development.</emphasis>
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-sequencer-zip</emphasis>
            is a DNA sequencer that extracts from ZIP archives the files (with content) and folders.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-sequencer-xml</emphasis>
            is a DNA sequencer that extracts the structure and content from XML files.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-sequencer-images</emphasis>
            is a DNA sequencer that extracts the image metadata (e.g., size, date, etc.) from PNG, JPEG, GIF, BMP, PCS, IFF,
            RAS, PBM, PGM, and PPM image files.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-sequencer-mp3</emphasis>
            is a DNA sequencer that extracts metadata (e.g., author, album name, etc.) from MP3 audio files.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-sequencer-java</emphasis>
            is a DNA sequencer that extracts the package, class/type, member, documentation, annotations, and other information
            from Java source files.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-sequencer-msoffice</emphasis>
            is a DNA sequencer that extracts metadata and summary information from
            <ulink url="http://office.microsoft.com/en-us/">Microsoft Office</ulink>
            documents. For example, the sequencer extracts from a PowerPoint presentation the outline as well as thumbnails of
            each slide. Microsoft Word and Excel files are also supported.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-sequencer-cnd</emphasis>
            is a DNA sequencer that extracts JCR node definitions from JCR Compact Node Definition (CND) files.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-sequencer-jbpm-jpdl</emphasis>
            is a prototype DNA sequencer that extracts process definition metadata from jBPM process definition language (jPDL) files.
						<emphasis>This is still under development.</emphasis>
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">dna-sequencer-java</emphasis>
            is a DNA sequencer that extracts the structure (methods, fields) from Java source files.
          </para>
        </listitem>        
        <listitem>
          <para>
            <emphasis role="strong">dna-mimetype-detector-aperture</emphasis>
            is a DNA MIME type detector that uses the
            <ulink url="http://aperture.sourceforge.net/">Aperture</ulink>
            library to determine the best MIME type from the filename and file contents.
          </para>
        </listitem>
      </itemizedlist>
      There are also documentation modules (located in the source under the
      <code>docs/</code>
      directory):
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="strong">docs-getting-started</emphasis>
            is the project with the
            <ulink url="http://www.docbook.org/">DocBook</ulink>
            source for the JBoss DNA Getting Started document.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">docs-getting-started-examples</emphasis>
            is the project with the Java source for the example application used in the JBoss DNA Getting Started document.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">docs-reference-guide</emphasis>
            is the project with the
            <ulink url="http://www.docbook.org/">DocBook</ulink>
            source for this document, the JBoss DNA Reference Guide document.
          </para>
        </listitem>
      </itemizedlist>
      Finally, there is a module that represents the whole JBoss DNA project:
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="strong">dna</emphasis>
            is the parent project that aggregates all of the other projects and that contains some asset files to create the
            necessary Maven artifacts during a build.
          </para>
        </listitem>
      </itemizedlist>
      Each of these modules is a Maven project with a group ID of
      <code>org.jboss.dna</code>
      . All of these projects correspond to artifacts in the
      <ulink url="&JBossMaven;">JBoss Maven 2 Repository</ulink>
      .
    </para>
  </sect1>
</chapter>
