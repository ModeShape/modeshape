#
# ModeShape (http://www.modeshape.org)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

initializing = {0} version {1}

engineStarting = ModeShape engine starting...
engineStarted = ModeShape engine started in {0} ms
couldNotStartEngine = Could not start the ModeShape engine
engineStopping = ModeShape engine stopping...
engineStopped = ModeShape engine stopped in {0} ms
repositoryCannotBeRestored = The '{0}' repository cannot be restored: {1}
repositoryCannotBeRestartedAfterRestore = The '{0}' repository cannot be restarted after being restored: {1}
repositoryIsBeingRestoredAndCannotBeStarted = The '{0}' repository is being restored and may not be started
repositoryIsCurrentlyBeingRestored = The '{0}' repository is currently being restored
repositoryCannotBeStartedWithoutTransactionalSupport = The '{0}' repository cannot be started because transactions are not enabled. Please check your configuration.
workspaceCacheShouldNotBeTransactional = The '{0}' workspace cannot be initialized because it is configured with a transactional cache. Workspace caches should not be transactional. Please check your configuration.
repositoryReferencesNonExistantSource = The '{0}' repository references the '{1}' repository source that does not exist
indexRebuildingStarted = Started rebuilding indexes for repository '{0}'
indexRebuildingComplete = Completed rebuilding indexes for repository '{0}'
indexRebuildingOfWorkspaceStarted = Started rebuilding indexes for workspace '{1}' in repository '{0}'
indexRebuildingOfWorkspaceComplete = Completed rebuilding indexes for workspace '{1}' in repository '{0}'
unableToInitializeSystemWorkspace = Unable to initialize the '/jcr:system' content in repository '{0}'
repositoryWasNeverInitializedAfterMinutes = Repository '{0}' is still not fully initialized after {1} minutes. Aborting.
repositoryWasInitializedByOtherProcess = Repository '{0}' has been initialized by another process while holding a cluster-wide lock. Cluster seems corrupt, aborting.
repositoryWasNeverUpgradedAfterMinutes = Repository '{0}' is still not fully upgraded after {1} minutes. SOME PROBLEMS MAY EXIST BECAUSE OF THIS.
failureDuringUpgradeOperation = Repository '{0}' could not be upgrade due to a failure of the upgrade steps: {1}

cannotConvertValue = Cannot convert {0} value to {1}
loginFailed = Unable to create session for workspace {1} in repository {0}: authentication or authorization failed. Check credentials.
noPrivilegeToGetLoginContextFromCredentials = No privilege to get LoginContext from the supplied credentials class '{0}'. Check security privileges for classes.
credentialsMustProvideJaasMethod = The Credentials class "{0}" must implement "public LoginContext getLoginContext();", be an instance of "javax.jcr.SimpleCredentials", or be an instance of "org.modeshape.jcr.SecurityContextCredentials"
mustBeInPrivilegedAction=Expected 'login' method on '{0}' repository and '{1}' workspace to be called within a java.security.PrivilegedAction (when using {2})
loginConfigNotFound = The JAAS policy named '{0}' (nor the policy named 'other') could not be found; check the value of the '{1}' repository option in the configuration for the '{2}' repository (or ignore this message if JAAS authentication is not being used)
credentialsMustReturnLoginContext = The "getLoginContext()" method in Credentials class "{0}" may not return null
usingAnonymousUser = Invalid credentials provided.  Using anonymous user context.
unknownCredentialsImplementation = ModeShape does not know how to use the "{0}" implementation of javax.jcr.Credentials
defaultWorkspaceName=
nodeNotFound = No node exists at path '{0}' in workspace "{1}"
pathNotFound = No item exists at path '{0}' in workspace "{1}"
pathNotFoundRelativeTo = No item exists at path {0} relative to {1} in workspace "{2}"
pathCannotHaveSameNameSiblingIndex = The path specified by the argument "{0}" cannot have a same-name-sibling index
cannotCopySubgraphIntoRoot = Cannot copy the subgraph of nodes starting at "{0}" from the workspace "{1}", into the root of the "{2}" workspace
cannotCloneSubgraphIntoRoot = Cannot clone the subgraph of nodes starting at "{0}" from the workspace "{1}", into the root of the "{2}" workspace
cannotCopyOrCloneReferenceOutsideGraph = Cannot copy/clone reference property "{0}" because the target of this reference "{1}" is outside the graph of nodes starting at "{2}"
cannotCopyOrCloneCorruptReference = Cannot copy/clone because the reference property "{0}" with the value "{1}" is corrupt. It is a strong reference which cannot be resolved in the source workspace.
permissionDenied = Permission denied to perform actions "{1}" on path {0}
repositoryMustBeConfigured = ModeShape repositories must be configured with either a repository source factory or a repository source
sourceInUse = All sessions must end before a new repository source can be set
repositoryDoesNotExist = There is no repository named "{0}"
fileDoesNotExist = Unable to find or read the file "{0}"
failedToReadPropertiesFromManifest = Error reading manifest properties: {0}
failedToReadPropertyFromManifest = "{0}" property not found in manifest
errorLoadingNodeTypeDefintions = Error loading CND file "{0}": {1}
errorStartingRepositoryCheckConfiguration = Error starting the "{0}" repository (check the configuration): {1}
startingAllRepositoriesWasInterrupted = The engine was interrupted while starting each repository, and will be left in an unknown state: {0}
completedStartingRepository = Completed starting the "{0}" repository
unableToFindNodeTypeDefinitionsOnClasspathOrFileOrUrl = Unable to find the node type definition file "{0}" on the classpath, as a relative or absolute file, or resolve as a URL
unableToFindResourceOnClasspathOrFileOrUrl = Unable to find "{0}" on the classpath, as a relative or absolute file, or resolve as a URL
unableToImportInitialContent = Unable to import initial content for repository "{0}" from "{1}". Check that this file exists on the file system or classpath.
fileMustExistAndBeReadable = The file at "{0}" must exist and be readable
existsAndMustBeWritableDirectory = The location "{0}" exists and is expected to be a directory but is a file
problemInitializingBackupArea = Error while initializing the backup area "{0}": {1}
problemsWritingDocumentToBackup = Problems writing document "{0}" to backup: {1}
problemsWritingBinaryToBackup = Problems writing binary value with SHA-1 "{0}" to backup {1}: {2}
problemsGettingBinaryKeysFromBinaryStore = Problem getting the binary keys from the binary store in the "{0}" repository for the backup {1}: {2}
problemsReadingBinaryFromBackup = Unable to read binary value {0} from backup for repository '{1}' at {2} - check permissions
problemsRestoringBinaryFromBackup = Problems restoring binary value {0} from backup for repository '{1}' at {2}: {3}
interruptedWhilePerformingBackup = Backup of '{0}' to {1} was interrupted and has been aborted: {2}
problemObtainingDocumentsToBackup = Problem obtaining the set of documents to backup repository '{0}' to {1}: {2}
backupOperationWasCancelled = Aborting performing the backup of repository '{0}' to {1}: {2}
problemsClosingBackupFiles = Problems closing backup files in "{0}": {1}
invalidJcrUrl = A valid JCR URL must be provided to use this method.  "{0}" is not a valid JCR URL.  Please consult the ModeShape Reference Guide for information on providing a valid JCR URL.
unableToInitializeAuthenticationProvider = Unable to initialize authentication provider "{0}" for repository "{1}": {2}
errorInAuthenticationProvider = Exception in the "{0}" authentication provider for repository "{1}": {2}
unableToInitializeSequencer = Unable to initialize the sequencer "{0}" for repository "{1}": {2}
unableToInitializeTextExtractor = Unable to initialize the text extractor "{0}" for repository "{1}": {2}
unableToInitializeConnector = Unable to initialize the connector "{0}" for repository "{1}": {2}
requiredFieldNotSetInConnector = The external source "{0}" of type "{1}" is missing a required "{2}" property
fileConnectorCannotWriteToDirectory = The external source "{0}" of type "{1}" cannot write to the "{2}" directory
fileConnectorTopLevelDirectoryMissingOrCannotBeRead = The file system external source "{0}" expects a readable, existing directory for the '"{1}"' property.
fileConnectorNodeIdentifierIsNotWithinScopeOfConnector = The file system external source "{0}" cannot work with a node with ID of "{2}" because it is out of the scope of the source: "{1}"
fileConnectorIsReadOnly = The file system external source "{0}" is read-only and cannot update the file or directory at "{1}" on the file system at "{2}".
fileConnectorCannotStoreFileThatIsExcluded = The file system external source "{0}" excludes the file or directory at "{1}" on the file system at "{2}" and therefore cannot save or update it
fileConnectorNamespaceIgnored = The file system external source "{0}" does not support namespaces in file/folder names. The namespace "{1}" will be ignored by the connector on document "{2}" for child "{3}" under "{4}"
couldNotStoreProperties = The external source "{0}" cannot store these extra properties on node "{1}": {2}
couldNotStoreProperty = The external source "{0}" cannot store the extra property "{2}" on node "{1}"
couldNotGetMimeType = The external source "{0}" cannot get the MIME type on node "{1}": {2}
connectorIsReadOnly = The external source "{0}" is read-only and therefore does not support adding/updating and removing nodes.

rootNodeHasNoParent = The root node has no parent node
rootNodeIsNotProperty = The root path "/" refers to the root node, not a property
childNodeAlreadyExists = A child node named "{0}" already exists at node "{1}"

noNamespaceWithPrefix = There is no namespace with prefix "{0}"
noNamespaceWithUri = There is no namespace with URI "{0}"
unableToChangeTheDefaultNamespace = The default namespace is reserved and cannot be changed
unableToRegisterReservedNamespacePrefix = Unable to register the namespace "{1}" with prefix "{0}" because this prefix is reserved
unableToRegisterReservedNamespaceUri = Unable to register the namespace "{1}" with prefix "{0}" because this URI is reserved
unableToRegisterNamespaceUsingXmlPrefix = Unable to register the namespace "{1}" with prefix "{0}" because prefixes starting with 'xml' (in any case) are reserved
unableToRegisterNamespaceWithInvalidPrefix = Unable to register the namespace "{1}" with prefix "{0}" because the prefix must be a valid XML NCName
errorRegisteringPersistentNamespace = Error registering the persisted namespace "{1}" with prefix "{0}"
unableToUnregisterReservedNamespacePrefix = Unable to unregister the namespace "{1}" with prefix "{0}" because this prefix is reserved
unableToUnregisterReservedNamespaceUri = Unable to unregister the namespace "{1}" with prefix "{0}" because this URI is reserved
unableToUnregisterPrefixForNamespaceThatIsNotRegistered = The namespace with prefix "{0}" is not registered and cannot be unregistered
unableToUnregisterPrefixForNamespaceUsedByNodeType = The namespace with URI "{0}" cannot be unregistered because the node type "{1}" uses it.

errorCleaningUpLocks = Error while cleaning up locks for the "{0}" repository
errorRefreshingLocks = Error while refreshing locks for the "{0}" repository
cleaningUpLocks = Lock clean up process begun
cleanedUpLocks = Lock clean up process completed
errorWhileInitializingTheNamespaceRegistry = Error while initializing the namespace registry for workspace "{0}"
invalidRelativePath = "{0}" is not a valid relative path
invalidAbsolutePath = "{0}" is not a valid absolute path
invalidPathParameter = The "{1}" parameter value "{0}" was not a valid path
invalidNamePattern = The "{1}" name pattern contained the '{0}' character, which is not allowed in a name pattern
invalidNodeTypeNameParameter = The "{1}" parameter value "{0}" was not a valid node type name
noPrimaryItemNameDefinedOnPrimaryType = The primary type "{0}" for node "{1}" in workspace "{2}" does not define a primary item name
primaryItemNameForPrimaryTypeIsNotValid = Node "{2}" in workspace "{3}" does not have an item named "{1}" as defined by the primary type "{0}"
primaryItemDoesNotExist = The node "{2}" in workspace "{3}" does not have an item named "{1}" as defined by its primary type "{0}"
itemNotFoundWithUuid = An item with UUID "{0}" could not be found in workspace "{1}"
itemAlreadyExistsWithUuid = An item with UUID "{0}" already exists in workspace "{1}" at "{2}"
itemNotFoundAtPath = An item at "{0}" could not be found in workspace "{1}"
itemNotFoundAtPathRelativeToReferenceNode = An item at "{0}" relative to "{1}" could not be found in workspace "{2}"
identifierPathContainedUnsupportedIdentifierFormat = The identifier path "{0}" does not contain a known identifier format
identifierPathNeverReferencesProperty = Identifier paths such as "{0}" only point to nodes, and never to properties
propertyNotFoundOnNode = Property "{0}" does not exist on node "{1}" in workspace "{2}"
propertyNotFoundAtPathRelativeToReferenceNode = A property at "{0}" relative to "{1}" could not be found in workspace "{2}"
nodeNotFoundAtPathRelativeToReferenceNode = A node at "{0}" relative to "{1}" could not be found in workspace "{2}"
childNotFoundUnderNode = The child "{0}" could not be found under "{1}" in workspace "{2}"
errorWhileFindingNodeWithUuid = Error while finding the node with UUID "{0}" in workspace "{1}": {2}
errorWhileFindingNodeWithPath = Error while finding the node "{0}" in workspace "{1}"
nodeDefinitionCouldNotBeDeterminedForNode = Unable to determine a valid node definition for the node "{0}" in workspace "{1}" of "{2}"
noSnsDefinitionForNode = A node definition that allows same name siblings could not be found for the node "{0}" in workspace "{1}"
missingNodeTypeForExistingNode = Missing primary node type "{0}" for node {1} in workspace "{2}" of "{3}"
unableToCreateNodeWithInternalPrimaryType = Unable to create node at "{1}" in workspace "{2}" because the node type "{0}" is reserved for used by ModeShape
unableToCreateNodeWithPrimaryTypeThatDoesNotExist = Unable to create child "{1}" in workspace "{2}" because the node type "{0}" does not exist
unableToCreateNodeWithNoDefaultPrimaryTypeOnChildNodeDefinition = Unable to create child "{2}" in workspace "{3}" because the node definition "{0}" on the "{1}" node type has no default primary type 
unableToSaveNodeThatWasCreatedSincePreviousSave = Unable to save node "{0}" in workspace "{1}" because it was created since the last save
unableToSetMultiValuedPropertyUsingSingleValue = Unable to set existing multi-valued property "{0}" on node "{1}" in workspace "{2}" using single-value setter methods
cannotSetProtectedPropertyValue = Unable to set a value "{0}" for a protected property "{1}" on node "{2}" in workspace "{3}"
unableToSetSingleValuedPropertyUsingMultipleValues = Unable to set existing single-valued property "{0}" on node "{1}" in workspace "{2}" using multi-value setter methods
invalidMethodForSingleValuedProperty = This method cannot be called on a property with a single value
invalidMethodForMultiValuedProperty = This method cannot be called on a property with multiple values
indexOutsidePropertyValuesBoundaries = The index "{0}" is outside the boundary of values for the property. Total values count is "{1}"
unableToRefreshBranchBecauseChangesDependOnChangesToNodesOutsideOfBranch = Unable to refresh "{0}" in workspace "{1}" because it contains changes that depend on changes to nodes outside of this branch
unableToSaveBranchBecauseChangesDependOnChangesToNodesOutsideOfBranch = Unable to save "{0}" in workspace "{1}" because it contains changes that depend on changes to nodes outside of this branch
unableToConvertPropertyValueToType = Unable to convert the value for the "{0}" property to "{1}"
unableToConvertPropertyValueAtIndexToType = Unable to convert the value for the "{0}" property at index "{1}" to "{2}"
allPropertyValuesMustHaveSameType = All values of property "{0}" on node "{3}" in workspace "{4}" must all be {2} values (values were: {1})
cannotRemoveNodeFromClone = The node at "{0}" with UUID "{1}" exists in the current workspace but cannot be removed because it is a mandatory child node
cannotRemoveNodeFromCloneDueToChangesInSession = The node at "{0}" with UUID "{1}" already exists in the current workspace and would be removed by the clone, but that node has been changed within this session and therefore cannot be removed
constraintViolatedOnReference = The property "{0}" on node "{1}" does not satisfy the constraints defined on the "{2}" property definition
unableToBindToJndi = Error while binding repository '{0}' into JNDI at '{1}' : {2}
jndiReadOnly = The repository '{0}' cannot be bound/unbound in JNDI at '{1}' because the JNDI context is read-only.
invalidOptionProvided = The provided option {0} is not a valid ModeShape option, it will be ignored
noOptionValueProvided = No value provided for option {0}, it will be ignored
valueMayNotContainNull = The value for the '{0}' property is invalid because the javax.jcr.Value object contains a null reference. To remove the value, a null javax.jcr.Value reference may be used.
propertyNoLongerSatisfiesConstraints = The values for the '{0}' property on node '{1}' no longer satisfy the type and/or constraints on the '{2}' property definition on the '{3}' node type definition
propertyNoLongerHasValidDefinition = No valid property definition on node '{1}' with primary type '{2}' and mixin types {3} for the property: {0}
propertyIsProtected = The property '{0}' is protected and cannot be removed.

cannotRemoveRootNode = Unable to remove the root node
cannotRemoveParentNodeOfTarget = The node at "{0}" with UUID "{1}" is a parent of the target node for this operation "{2}"
invalidPropertyType = Invalid property type: {0}
 
rootNodeCannotBeDestinationOfMovedNode = The root node in workspace "{1}" cannot be the destination for moving
unableToMoveRootNode = Unable to move the root node in workspace "{1}"
unableToRemoveRootNode = Unable to remove the root node in workspace "{1}"
unableToRemoveSystemNodes = Unable to remove the '{0}' node in workspace "{1}" becasue the node is within the '/jcr:system' area
unableToModifySystemNodes = Unable to modify the '{0}' node in workspace "{1}" because the node is within the '/jcr:system' area
unableToMoveNodeToBeChildOfDecendent = Node "{0}" in workspace "{2}" cannot be moved under a decendant node ("{1}") 
nodeHasAlreadyBeenRemovedFromThisSession = Node "{0}" in workspace "{1} has already been removed from this session
unableToShareNodeWithinSubgraph = Unable to share '{0}' at '{1}' since it would create a circularity
unableToShareNodeWithinSameParent = Unable to share '{0}' at '{1}' since it has already been shared at '{2}'
unableToMoveNodeDueToCycle = Unable to move node at '{0}' to '{1}' since '{2}' would reate a circularity
shareAlreadyExistsWithinParent = Unable to create share at '{0}' because there is already a share at '{1}'
unableToMoveSourceContainExternalNodes = Unable to move the nodes because the source path "{0}" contains at least a node which belongs to the external source "{1}"
unableToMoveTargetContainExternalNodes = Unable to move the nodes because the node at the target path "{0}" belongs to the external source "{1}"
unableToMoveSourceTargetMismatch = Unable to move the nodes because the source nodes belong to the "{0}" source while the destination node belongs to the "{1}" source
unableToMoveProjection = Unable to move the nodes because the path "{0}" represents a projection
unableToCopySourceTargetMismatch =  Unable to copy the nodes because at least one of the source nodes belong to the "{0}" source while the destination node belongs to the "{1}" source
unableToCopySourceNotExternal =  Unable to copy the nodes because the source node "{0}" is not an external node itself, but its subgraph contains external nodes.
unableToCloneSameWsContainsExternalNode =  Unable to perform the clone operation in the same workspace because at least one of the source nodes belongs to the "{0}" source
unableToCloneExternalNodesRequireRoot = At least one of the source nodes belongs to the "{0}" source. Only entire workspaces can be cloned if the source workspace contains external nodes

SPEC_NAME_DESC = Content Repository for Java Technology API

errorObtainingWorkspaceNames = Error while obtaining the workspace names for the "{0}" repository: {1}
errorObtainingDefaultWorkspaceName = Error while obtaining the default workspace names for the "{0}" repository: {1}
errorUpdatingWorkspaceNames = Error while updating the workspace names for the "{0}" repository: {1}
errorUpdatingRepositoryMetadata = Error while updating the internal metadata for the "{0}" repository: {1}
workspaceNameIsInvalid = "{1}" is not a valid workspace name for the "{0}" repository
errorVerifyingWorkspaceName =Error validating the workspace name "{1}" for the "{0}" repository\: {2}

typeNotFound=No type exists with name "{0}"
supertypeNotFound=Could not find type "{0}" which is a required supertype of type "{1}"
errorImportingNodeTypeContent = Error importing node types from "{0}": {1}
errorDuringInitialImport = Error while importing initial content: {0}
nodeTypesNotFoundInXml = No valid node types elements found in the XML in "{0}"

invalidGarbageCollectionInitialTime = The initial time specified for the garbage collection in repository '{0}' was not valid: {1}

failedToQueryForDerivedContent = Error while querying for content in workspace "{0}" derived from (re)moved paths, using this query: {1}

systemSourceNameOptionValueDoesNotReferenceExistingSource = The JCR Repository 'SYSTEM_SOURCE_NAME' option value "{0}" references an invalid or non-existant source "{1}"
systemSourceNameOptionValueDoesNotReferenceValidWorkspace = The JCR Repository 'SYSTEM_SOURCE_NAME' option value "{0}" references an invalid or non-existant workspace in the "{1}" source
systemSourceNameOptionValueIsNotFormattedCorrectly = The JCR Repository 'SYSTEM_SOURCE_NAME' option value "{0}" is invalid or improperly formatted

searchIndexDirectoryOptionSpecifiesFileNotDirectory = The JCR Repository '{1}' option value "{0}" specifies an existing file on the local file system, but a directory is required
searchIndexDirectoryOptionSpecifiesDirectoryThatCannotBeRead = The JCR Repository '{1}' option value "{0}" specifies a directory on the local file system that cannot be read
searchIndexDirectoryOptionSpecifiesDirectoryThatCannotBeWrittenTo = The JCR Repository '{1}' option value "{0}" specifies a directory on the local file system that cannot be written
searchIndexDirectoryOptionSpecifiesDirectoryThatCannotBeCreated = The JCR Repository '{1}' option value "{0}" specifies a non-existant directory on the local file system that cannot be created
errorUpdatingQueryIndexes = Error updating the query indexes: {0}

invalidAliasForComponent = The '{0}' value "{1}" is not recognized; allowed values are: {2}
unableToSetFieldOnInstance = Unable to set the '{0}' field on an instance of '{2}' to '{1}' 
missingFieldOnInstance = The field {0} is not present on {1} or any of its super types
missingComponentType = The component type is required, and must be either a classname or a valid alias: {0}
repositoryConfigurationContainsDeprecatedField = The '{0}' field in the repository configuration file is deprecated and is no longer used. {1}

typeMissingWhenRegisteringEngineInJndi = JNDI registration of engine at "{0}": the 'type' parameter should be specified with a value of '{1}'
repositoryNameNotProvidedWhenRegisteringRepositoryInJndi = JNDI registration failed: unable to register in JNDI a repository at "{0}" because a 'repositoryName' parameter was not provided
invalidRepositoryNameWhenRegisteringRepositoryInJndi = JNDI registration failed: unable to register in JNDI a repository at "{0}" because the 'repositoryName' parameter with value "{1}" does not match the known repositories: {2}
emptyRepositoryNameProvidedWhenRegisteringRepositoryInJndi = JNDI registration failed: unable to register in JNDI a repository at "{0}" because the 'repositoryName' parameter was empty or contained only whitespace

noNegativeDepth=Depth parameter ({0}) cannot be negative
tooDeep=Depth parameter ({0}) cannot be greater than the result of getDepth() for this node

notStoredQuery=This query has not been stored or loaded: {0}
invalidQueryLanguage="{0}" is not a valid query langauge.  Supported languages are\: {1}
queryCannotBeParsedUsingLanguage=The {0} query "{1}" is not well-formed: {2}
queryInLanguageIsNotValid=The {0} query "{1}" has one or more errors: {2}
queryIsDisabledInRepository = The {0} repository does not have queries enabled
queryResultsDoNotIncludeScore = The query does not include the score in the results: {0}
queryResultsDoNotIncludeColumn = The column '{0}' does not appear in the results for query: {1}
selectorNotUsedInQuery = The selector '{0}' was not used in the query: {1}
selectorUsedInEquiJoinCriteriaDoesNotExistInQuery = The selector '{0}' used in the equijoin criteria (at line {1} and column {2}) does not exist in the query
multipleSelectorsAppearInQueryRequireSpecifyingSelectorName = Selector name must be specified when the query contains multiple selectors: {0}
multipleSelectorsAppearInQueryUnableToCallMethod = As stipulated by the JCR API, it is not possible to return an iterator over the nodes in the results for a query with multiple selectors, since each result row may contain multiple nodes: {0}
equiJoinWithOneJcrPathPseudoColumnIsInvalid = Equi-join condition using one 'jcr:path' column is not valid: expected "... [{0}].[jcr:path] = [{1}].[jcr:path] ..."
noSuchVariableInQuery = The variable '{0}' is not used in the query: {1}

invalidNodeTypeName=Node types cannot have a null or empty name
badNodeTypeName={0} cannot have a null or invalid name
noSuchNodeType=Type named '{0}' does not exist
nodeTypeAlreadyExists=Node type '{0}' already exists
invalidPrimaryTypeName=Required primary type '{0}' in type '{1}' does not exist
invalidMixinSupertype=The '{0}' mixin has the non-mixin '{1}' defined as a supertype. A mixin may only have other mixins as supertypes.
invalidSupertypeName=Supertype '{0}' from type '{1}' does not exist
supertypesConflict=Types '{0}' and '{1}' cannot both be supertypes of the same type, as both separately declare {2} '{3}'
ambiguousPrimaryItemName=Primary item name '{0}' matches the name of a child node and a property
invalidPrimaryItemName=Primary item name '{0}' does not match the name of any child nodes or properties
autocreatedNodesNeedDefaults=Autocreated child node '{0}' must specify a default primary type
residualPropertyDefinitionsCannotBeMandatory=The property definition '{0}' is not valid: residual definitions cannot be mandatory
residualPropertyDefinitionsCannotBeAutoCreated=The property definition '{0}' is not valid: residual definitions cannot be auto-created
residualNodeDefinitionsCannotBeMandatory=The node definition '{0}' is not valid: residual definitions cannot be mandatory
residualNodeDefinitionsCannotBeAutoCreated=The node definition '{0}' is not valid: residual definitions cannot be auto-created
cannotOverrideProtectedDefinition=Cannot override protected {1} definition from '{0}'
cannotMakeMandatoryDefinitionOptional=Cannot override mandatory {1} definition from '{0}' with a non-mandatory definition.
constraintsChangedInSubtype=Must use exact same constraints or a subset of the constraint literals when overriding the property definition for {0} from type '{1}'
cannotRedefineProperty=Cannot redefine property '{0}' with new type '{1}' when existing property with same name in type '{2}' has incompatible type '{3}'
autocreatedPropertyNeedsDefault=Auto-created property '{0}' in type '{1}' must specify a default value
singleValuedPropertyNeedsSingleValuedDefault=Single-valued property '{0}' in type '{1}' cannot have multiple default values
couldNotFindDefinitionOfRequiredPrimaryType = Could not find node type definition for the type of required primary type "{0}" while validating child node definition "{1}" of node type "{2}"
cannotRedefineChildNodeWithIncompatibleDefinition = Cannot redefine child node "{0}" with required type "{1}" in node type "{2}" with new child node that does not require that type or a subtype of that type.
cannotRemoveItemWithProtectedDefinition = Cannot remove the item at '{0}' with a protected definition
errorCheckingNodeTypeUsage = Error while determining if node type '{0}' is used: {1}

noChildNodeDefinition=Cannot find a definition for a child named '{0}' on the node at '{1}' with primary type '{2}' and mixin types: {3}
noPropertyDefinition=Cannot find a definition for the property named '{0}' on the node at '{1}' with primary type '{2}' and mixin types: {3}
noSnsDefinition=Cannot find a definition that allows same-name siblings for the child node named '{0}' on the node at '{1}' with primary type '{2}' and mixin types: {3} and a child node already exists with this name
missingMandatoryProperty=The mandatory property named '{0}' defined in type '{1}' is missing from the node at '{2}'
missingMandatoryChild=The mandatory child node named '{0}' defined in type '{1}' is missing from the node at '{2}'
valueViolatesConstraintsOnDefinition=The '{0}' property value '{1}' on node '{2}' does not satisfy the constraints of the '{3}' property definition on the '{4}' node type, and no other property definition is valid.
valuesViolateConstraintsOnDefinition=One or more of the '{0}' property values {1} on node '{2}' does not satisfy the constraints of the '{3}' property definition on the '{4}' node type, and no other property definition is valid.
referenceValueViolatesConstraintsOnDefinition=The '{0}' REFERENCE property value '{1}' on node '{2}' does not satisfy the constraints of the '{3}' property definition on the '{4}' node type, and no other property definition is valid.
referenceValuesViolateConstraintsOnDefinition=One or more of the '{0}' REFERENCE property values {1} on node '{2}' does not satisfy the constraints of the '{3}' property definition on the '{4}' node type, and no other property definition is valid.
weakReferenceValueViolatesConstraintsOnDefinition=The '{0}' WEAKREFERENCE property value '{1}' on node '{2}' does not satisfy the constraints of the '{3}' property definition on the '{4}' node type, and no other property definition is valid.
weakReferenceValuesViolateConstraintsOnDefinition=One or more of the '{0}' WEAKREFERENCE property values {1} on node '{2}' does not satisfy the constraints of the '{3}' property definition on the '{4}' node type, and no other property definition is valid.

allNodeTypeTemplatesMustComeFromSameSession=All node type templates must be created from the same javax.jcr.Session

nodeNotReferenceable=Only referenceable nodes may be the value of reference properties
nodeNotReferenceableUuid = Only referenceable nodes have a public UUID assigned
noPendingChangesAllowed=This operation cannot be performed when the session has pending changes
noPendingChangesAllowedForNode=This operation cannot be performed when the node has pending changes
nodeNotInTheSameSession=The node {0} cannot be referenced because it belongs to another session

cannotUnregisterSupertype=Cannot unregister type '{0}' which is supertype of type '{1}'
cannotUnregisterRequiredPrimaryType=Cannot unregister type '{0}' which is the required primary type for child node '{2}' on type '{1}'
cannotUnregisterDefaultPrimaryType=Cannot unregister type '{0}' which is the default primary type for child node '{2}' of type '{1}'
cannotUnregisterInUseType=Cannot unregister type '{0}' because it is currently being used on at least one node

cannotAddMixin = This node does not allow adding the mixin type "{0}"
invalidMixinTypeForNode = "{0}" is not currently a mixin type for node "{1}"
notOrderable = The primary type "{0}" for this node (at "{1}") does not have orderable children
cannotUseMixinTypeAsPrimaryType = This operation requires a primary type, but "{0}" is a mixin type
unableToChangePrimaryTypeDueToPropertyDefinition = Unable to change the primary type of node '{0}' from '{1}' to '{2}' because the '{3}' property would no longer be valid
unableToChangePrimaryTypeDueToParentsChildDefinition = Unable to change the primary type of node '{0}' from '{1}' to '{2}' because there would be no valid child node definition in the parent node with its primary type of '{3}' and mixin types of {4}
primaryTypeCannotBeAbstract = The primary type of a node cannot be abstract, like "{0}"
setPrimaryTypeOnRootNodeIsNotSupported = ModeShape does not support modifying the root node's primary type
suppliedNodeTypeIsNotMixinType = The specified node type '{0}' is not a mixin, and cannot be used as a mixin.
cannotRemoveShareableMixinThatIsShared = Unable to remove the 'mix:shareable' mixin from the node '{0}' since it is currently shared at {1} places: {2}

errorReadingNodeTypesFromRemote = Node types changed due to remote update. Node types are likely to be different across nodes in the cluster.  Encountered following errors reading node types from graph: {0}
problemReadingNodeTypesFromRemote = Node types changed due to remote update. Encountered following problems reading node types from graph: {0}
errorSynchronizingNodeTypes = Node types changed due to remote update.  Could not rebuild node type map.  Node types are likely to be different across nodes in the cluster.

errorRefreshingNodeTypesFromSystem = Encountered the following error(s) while reading the node types from the system content: {0}
problemRefreshingNodeTypesFromSystem = Encountered following problems reading node types from system content: {0}
errorRefreshingNodeTypes = Node types were read from the system content, and appear to be inconsistent or invalid: {0}

errorsParsingNodeTypeDefinitions = Reading the node definitions from '{0}' resulted in problems(s): {1}
errorsParsingStreamOfNodeTypeDefinitions = Reading the node definitions from the supplied stream resulted in problems(s): {0}
warningsParsingNodeTypeDefinitions = Reading the node definitions from '{0}' resulted in warnings(s): {1}
warningsParsingStreamOfNodeTypeDefinitions = Reading the node definitions from the supplied stream resulted in warnings(s): {0}

referentialIntegrityException = Cannot remove the nodes: '{0}' because there are existing nodes: '{1}' which have strong references towards them.

# Lock messages
nodeNotLockable = The node at '{0}' is not lockable.  Add the 'mix:lockable' mixin type to make it lockable.
cannotRemoveLockToken = The lock token '{0}' is a session-scoped lock
nodeIsLocked = The node at '{0}' is locked and cannot be modified
alreadyLocked = The node at '{0}' is already locked
parentAlreadyLocked = The node at '{0}' cannot be locked because the parent node '{1}' is already locked
descendantAlreadyLocked = The node at location '{0}' cannot be locked because the descendant node '{1}' is already locked.
notLocked = The node at location '{0}' is not locked
lockTokenNotHeld = The node at location '{0}' is locked and this session does not hold its lock token
invalidLockToken = The lock token '{0}' is not valid
lockTokenAlreadyHeld = The lock token '{0}' is already held by another session.  It must be removed from that session before it can be added to another session.
changedNodeCannotBeLocked = The node at '{0}' has unsaved changes and cannot be locked.
changedNodeCannotBeUnlocked = The node at '{0}' has unsaved changes and cannot be unlocked.
uuidRequiredForLock = Only referenceable nodes can be locked.  The node at location '{0}' is not referenceable.

# JcrObservationManager messages
cannotCreateUuid = Factory was unable to create UUID from text '{0}'
cannotPerformNodeTypeCheck = Error checking primary type '{0}' with mixins of '{1}' against type names of '{2}'
sessionIsNotActive = The session with an ID of '{0}' has been closed and can no longer be used. 

# Versioning messages
nodeIsCheckedIn = '{0}' (or its nearest versionable ancestor) is checked in, preventing this action
cannotCreateChildOnCheckedInNodeSinceOpvOfChildDefinitionIsNotIgnore = Cannot add the child node named '{0}' under '{1}' because it is checked in and the child's node definition '{2}' has an on-parent-version attribute of '{3}' (must be 'ignore' to add child to checked-in parent)
cannotRemoveChildOnCheckedInNodeSinceOpvOfChildDefinitionIsNotIgnore = Cannot remove the child at '{0}' because the parent node is checked in and the child's node definition '{1}' has an on-parent-version attribute of '{2}' (must be 'ignore' to remove child from checked-in parent)
cannotRemoveFromProtectedNode = Mixins cannot be removed from the node at '{0}' because it has a protected node definition
cannotRemoveVersion = This version cannot be removed as the property at '{0}' still references it.  Remove that reference and try again.
pendingMergeConflicts = The node at '{0}' cannot be checked in due to existing merge conflicts stored in the 'jcr:mergeFailed property.
invalidVersion = The version at '{0}' is not valid for the version history at '{1}'
invalidVersionLabel = The version label '{0}' does not exist in the version history at '{1}'
invalidVersionName = The version name '{0}' does not exist in the version history at '{1}'
versionLabelAlreadyExists = The version label '{0}' is already in use in this version history
labeledNodeNotFound = The version label '{0}' on the history of '{1}' no longer points to a version
requiresVersionable = This operation requires that the node be versionable (that is, isNodeType("mix:versionable") == true)
cannotRestoreRootVersion = The versionable node at '{0}' cannot be restored to its root version
cannotCheckinNodeWithAbortProperty = The property '{0}' on the node at '{1}' has an onParentVersionAction of ABORT, preventing checkin
cannotCheckinNodeWithAbortChildNode = The child node '{0}' on the node at '{1}' has an onParentVersionAction of ABORT, preventing checkin
noExistingVersionForRestore = Workspace.restore(...) requires that at least one of the provided versions represents an existing node in the workspace
invalidVersionForRestore = Workspace.restore(...) requires that the provided version represents an existing node in the workspace
versionNotInMergeFailed = The version '{0}' is not present in the jcr:mergeFailed property for the node at '{1}'
unrootedVersionsInRestore = The restore operation failed because no node exists in the target workspace for the following versions: {0}
errorDuringCheckinNode = Error while performing checkin on '{0}' : {1}
noVersionHistoryForTransientVersionableNodes = Node '{0}' is versionable but was not yet persisted via Session.save(), and therefore no version history is available yet
versionHistoryForNewlyVersionableNodesNotAvailableUntilSave = Node '{0}' was made 'mix:versionable' in the session but this change has not been saved, and therefore no version history is available yet
versionHistoryNotEmpty = Cannot remove node '{0}' because its version history is not empty. Make sure all the versions have been removed before attempting to remove the node.
nodeIsShareable = Cannot remove node '{0}' because it is a shareable node.

creatingWorkspacesIsNotAllowedInRepository = Creating workspaces is not allowed in the '{0}' repository. Check the configuration.
workspaceHasBeenDeleted = The workspace "{0}" has been deleted.
unableToDestroyPredefinedWorkspaceInRepository = Unable to destroy the "{0}" workspace, since it was listed in the predefined workspaces for the "{1}" repository.
unableToDestroyDefaultWorkspaceInRepository = Unable to destroy the "{0}" workspace, since it is the default workspace for the "{1}" repository.
unableToDestroySystemWorkspaceInRepository = Unable to destroy the "{0}" workspace, since it is the system workspace for the "{1}" repository.
workspaceNotFound = Workspace "{0}" was not found in repository "{1}"
unableToRestoreAtAbsPathNodeAlreadyExists = Unable to restore a version at absolute path {0} because the node with key {1} already exists at this location.

unableToFindRepositoryConfigurationSchema = Unable to find the JSON Schema for ModeShape repository configuration files. Expected to find "{0}" on classpath.
unableToLoadRepositoryConfigurationSchema = Error loading the JSON Schema at "{0}" for ModeShape repository configuration files.
errorsInRepositoryConfiguration = The "{0}" repository configuration has {1} error(s) and cannot be deployed: {2}

engineIsNotRunning = The ModeShape engine is not running; make sure it was started.
engineAtJndiLocationIsNotRunning = The ModeShape engine in JNDI at '{0}' is not running; make sure it was started.
repositoryConfigurationIsNotValid = The configuration for the '{0}' repository has problems: {1}
startingOfRepositoryWasCancelled = Starting the '{0}' repository was cancelled.
startingOfRepositoryWasInterrupted = Starting the '{0}' repository was interrupted.
failedToShutdownDeployedRepository = Failed to shutdown the already-deployed '{0}' repository prior to redeploying with a new configuration.
repositoryIsAlreadyDeployed = There is already a deployed repository named '{0}'
repositoryIsNotRunningOrHasBeenShutDown = The '{0}' repository is not running and may have been shutdown by the administrator.
repositoryNotFoundInEngineAtJndiLocation = No repository named '{0}' could be found in the ModeShape engine in JNDI at '{1}'
repositoriesNotFoundInEngineAtJndiLocation = The object in JNDI at '{0}' was an instanceof '{1}' but was expected to be '{2}'.
potentialClasspathErrorAtJndiLocation = The object in JNDI at '{0}' was an instanceof the '{1}' class, but not the same class instance on ModeShape's class loader. Check the application classpath for duplicate JCR or ModeShape API JAR files.
errorStartingRepository = Error while starting '{0}' repository: {1}
storageRelatedConfigurationChangesWillTakeEffectAfterShutdown = Storage-related configuration changes cannot immediately apply to "{0}" because it is currently running, so they will take effect after the repository is shutdown.
errorShuttingDownJcrRepositoryFactory = Error while shutting down the JcrRepositoryFactory instance
repositoryNameDoesNotMatchConfigurationName = The repository name '{0}' does not match the '{1}' name given in the repository configuration at '{2}'
errorWhileShuttingDownRepositoryInJndi = Error while shutting down the '{0}' repository located in JNDI at '{1}'
errorWhileShuttingDownEngineInJndi = Error while shutting down the ModeShape engine located in JNDI at '{0}'
nodeModifiedBySessionWasRemovedByAnotherSession = This session tried to save changes to node with key '{0}', but it was removed by another session.
nodeCreatedBySessionUsedExistingKey = This session tried to create node '{0}' (with key '{1}'), but a node with that key already exists.

failedWhileRollingBackDestroyToRuntimeError = '{1}' error caused rollback in SessionCache.destroy(), but this rollback encountered an error: {0}
unexpectedException = Unexpected exception: {0}
errorDeterminingCurrentTransactionAssumingNone = Error while trying to determine if there is an active user transaction while using the "{0}" workspace: {1}
errorWhileRollingBackActiveTransactionUsingWorkspaceThatIsBeingDeleted = Unexpected error rolling back active transaction that involved workspace "{0}" that is being removed: {1}

configurationError = Error at {0} : {1}
configurationWarning = Warning at {0} : {1}

errorDuringGarbageCollection = Error during background garbage collection: {0}
errorMarkingBinaryValuesUnused = Error marking binary values unused: {0}
errorMarkingBinaryValuesUsed = Error marking binary values used: {0}
errorStoringMimeType = Error storing mime type: {0}
errorStoringExtractedText = Error storing extracted text: {0}
errorReadingExtractedText = Error reading extracted text: {0}

unableToReadTemporaryDirectory = Unable to read the temporary directory at "{0}" defined by the '{1}' system property
unableToWriteTemporaryDirectory = Unable to write to the temporary directory at "{0}" defined by the '{1}' system property
unableToPersistBinaryValueToFileSystemStore = Unable to write the binary value with SHA-1 hash "{0}" to the file system store; check permissions for path: {1}
unableToDeleteTemporaryFile = Unable to delete temporary file at "{0}": {1}
unableToFindBinaryValue = Unable to find binary value with key "{0}" within binary store at "{1}"
unableToFindBinaryValueInCache = Unable to find binary value with key "{0}" within binary store using Infinispan cache "{1}"
tempDirectorySystemPropertyMustBeSet = The temporary directory must be specified via the "{0}" system property
errorReadingBinaryValue = Error during reading of binary value: {0}
errorStoringBinaryValue = Error at storing of binary value: {0}
errorLockingBinaryValue = Unable to obtain lock to change binary value: {0}

errorKillingRepository = Error killing repository "{0}": {1}
errorKillingEngine = Error killing engine: {0}

errorExtractingTextFromBinary = Error extracting text from binary value {0}: {1}
errorAddingBinaryTextToIndex = Error adding full-text terms for binary value {0} to search index: {1}
errorRetrievingExtractedTextFile = Error retrieving the extracted text file for binary value {0}: {1}
missingQueryVariableValue = Variable "{0}" has no value
errorClosingLuceneReaderForIndex = Error while closing the Lucene index reader '{1}' for repository '{0}'
ignoringIndexingProperty = Ignoring query indexing property '{0}' of value '{1}'
locationForIndexesIsNotDirectory = Location "{0}" cannot be used for search indexes for workspace "{1}" because it is a directory
locationForIndexesCannotBeRead = Location "{0}" cannot be used for search indexes for workspace "{1}" because it cannot be read
locationForIndexesCannotBeWritten = Location "{0}" cannot be used for search indexes for workspace "{1}" because its contents cannot be written or updated
errorWhileCommittingIndexChanges = Error while committing changes to the indexes for the "{0}" workspace of the "{1}" source: {2}
errorWhileRollingBackIndexChanges = Error while rolling back changes to the indexes for the "{0}" workspace of the "{1}" source: {2}
missingVariableValue = Variable "{0}" has no value

unableToReadMediaTypeRegistry = Unable to read the media type registry file '{0}': {1}
unableToInitializeMimeTypeDetector = Unable to initialize the Tika MIME type detector by using the media type registry files {0}: {1}
noMimeTypeDetectorsFound = No MIME type detectors found. Automatic MIME type detection of binary values will be disabled.
invalidInitialContentValue = Invalid content '{0}' found in the configuration of the initial content for workspace '{1}'. Expected a simple string
cannotLoadInitialContentFile = Cannot load initial content file '{0}' using the environment loader
errorWhileReadingInitialContentFile = Error while reading the initial content file: {0}
errorWhileParsingInitialContentFile = Error while parsing the initial content file: {0}

errorDuringInitialInitialization = An error occurred during the initial (one time) initialization

cannotLoadCndFile = Cannot load CND file '{0}' from the classpath
errorReadingCndFile = Error reading CND file '{0}':

invalidUrl = The string '{0}' is not a valid URL
timeoutWhileShuttingRepositoryDown = A timeout occurred while waiting for a repository to be shut down
repositoryNotFound = Could not load or find a ModeShape repository named '{0}' using the URL '{1}' and params: {2}

federationNodeKeyDoesNotBelongToSource = The node key '{0}' does not belong to the '{1}' source. Only nodes from that source are allowed.
invalidProjectionPath = The path '{0}' is not a valid projection path
invalidProjectionExpression = The projection expression '{0}' does not match the expected format
projectedPathPointsTowardsInternalNode = Ignoring configured projection '{0}' for source '{1}' because the projected path '{2}' points towards an existing, internal node.
errorStoringProjection = Storing the projection in workspace '{0}' at '{1}' (with source name '{2}', external path '{3}' and alias '{4}') resulted in an error: {5}
errorRemovingProjection = Removing the projection in workspace '{0}' at '{1}' (with external node key '{2}') resulted in an error: {3}

reindexMissingNoIndexesExist = Re-indexing only missing indexes for repository {0}. Since no indexes exist, all content will be re-indexed.
noReindex = Index rebuild mode for repository {0} is 'never'. Any content that has not been indexed so far, will not be available to queries.
reindexAll = All content will be re-indexed for repository {0}.
noIndexesExist = Repository '{0}' cannot start because no indexes exist and the index rebuild configuration is '{1}'

errorCreatingDatabaseTable = Error attempting to create the database table '{0}' in '{1}' database at {2}: {3}

cannotLocateConnectionFactory = Cannot locate in JNDI the JMS connection factory: '{0}'
cannotLocateQueue = Cannot locate in JNDI the JMS queue: '{0}'
unexpectedJMSException = An unexpected JMS exception with the error code: '{0}' has occurred: {1}
incorrectJMSMessageType = Incorrect message type received by JMS listener. Expected: {0} but received: {1}
unknownIndexName = Unknown index name '{0}' received in JMS message
cannotReadJMSMessage = Cannot read information from JMS message. Error code: {0}, reason: {1}
errorWhileShuttingDownListener = Unexpected error while shutting down JMS listener. Error code: {0}, reason: {1}
errorWhileStartingUpListener = Cannot start up JMS listener on the master node. Error code: {0}, reason: {1}

enablingDocumentOptimization = ******> TECH PREVIEW DOCUMENT OPTIMIZATION FEATURE IS ***ENABLED*** FOR THE '{0}' REPOSITORY. THIS SHOULD NOT BE USED IN PRODUCTION. <******
beginChildrenOptimization = Beginning background optimization of children in the '{0}' repository
completeChildrenOptimization = Completed background optimization of children in the '{0}' repository ({1} duration): {2}
errorDuringChildrenOptimization = Error during background optimization of children in the '{0}' repository ({1} duration before error): {2}

mBeanAlreadyRegistered = JMX bean "{0}" has already been registered
cannotRegisterMBean = Cannot register MBean "{0}"
cannotUnRegisterMBean = Cannot un-register MBean "{0}"

upgrade3_6_0Running = Running ModeShape 3.6.0 upgrade function...
upgrade3_6_0CannotUpdateNodeTypes = ModeShape 3.6.0 upgrade error: cannot update the internal node types. Reason: "{0}"
upgrade3_6_0CannotUpdateLocks = ModeShape 3.6.0 upgrade error: cannot update existing locks. Reason: "{0}"

cannotStartJournal = Cannot start event journal
cannotStopJournal = Cannot stop event journal
journalHasNotCompletedReconciliation = The journal {0} was not able to complete reconciliation in the cluster {1} after a maximum of {2} milliseconds.