{
    "$schema" : "http://modeshape.org/3.0/repository-config#",
    "id" : "http://modeshape.org/3.0/repository-config#",
    "type" : "object",
    
    "additionalProperties" : false,
    "properties" : {
        "name" : {
            "type" : "string",
            "required" : true,
            "description" : "The name of the repository. If not provided, the name of the configuration file is used (minus the filename extension)."
        },
        "jndiName" : {
            "type" : "string",
            "description" : "The name in JNDI where this repository is to be registered. If not specified, the location is assumed to be 'java:jcr/local/<name>', where '<name>' is the repository name. Setting this field to an empty string signals that the repository should not be registered in JNDI."
        },
        "monitoring" : {
            "type" : "object",
            "description" : "The specification for the monitoring system for the repositories.",
            "additionalProperties" : false,
            "properties" : {
                "enabled" : {
                    "type" : "boolean",
                    "default" : true,
                    "description" : "The flag specifying whether the repositories should record monitoring statistics. This is enabled by default."
                }
            }
        },
        "storage" : {
            "type" : "object",
            "description" : "The specification of how to obtain the Infinispan cache used for storage.",
            "additionalProperties" : false,
            "properties" : {
                "cacheName" : {
                    "type" : "string",
                    "description" : "The name of the Infinispan cache that this repository should use. If not specified, the repository's name is used."
                },
                "cacheConfiguration" : {
                    "type" : "string",
                    "description" : "The name of the Infinispan configuration file for creating a new cache manager. If a file could not be found (on the thread context classloader, on the application's classpath, or on the system classpath), then the name is assumed to reference an existing Infinispan CacheContainer instance via a valid JNDI name or as the name of a service as defined by the local environment. If no such container is found, then a default Infinispan configuration (a basic, local mode, non-clustered cache) will be used."
                },
                "transactionManagerLookup" : {
                    "type" : "string",
                    "default" : "org.infinispan.transaction.lookup.GenericTransactionManagerLookup",
                    "description" : "The name of the Infinispan class that should be used to find the JTA transaction manager instance. It defaults to 'org.infinispan.transaction.lookup.GenericTransactionManagerLookup'"
                },
                "binaryStorage" : {
                    "type" : [
                        {
                            "type" : "object",
                            "additionalProperties" : false,
                            "properties" : {
                                "type" : {
                                    "type" : "string",
                                    "description" : "The specification of the transient binary store, which keeps BINARY values on disk in the temp directory.",
                                    "enum" : [ "transient" ]
                                },
                                "minimumBinarySizeInBytes" : {
                                    "type" : "integer",
                                    "default" : 4096,
                                    "description" : "The size threshold that dictates whether String and binary values should be stored in the binary store. String and binary values smaller than this value are stored with the node, whereas string and binary values with a size equal to or greater than this limit will be stored separately from the node and in the binary store, keyed by the SHA-1 hash of the value. This is a space and performance optimization that stores each unique large value only once. The default value is '4096' bytes, or 4 kilobytes."
                                },
                            }
                        },
                        {
                            "type" : "object",
                            "additionalProperties" : false,
                            "properties" : {
                                "type" : {
                                    "type" : "string",
                                    "description" : "The specification of the file-based binary store, which keeps BINARY values on disk in the specified directory.",
                                    "enum" : [ "file" ]
                                },
                                "directory" : {
                                    "type" : "string",
                                    "required" : true,
                                    "description" : "The location of the directory the file system under which the BINARY values should be stored. The value can be an absolute or relative path."
                                },
                                "minimumBinarySizeInBytes" : {
                                    "type" : "integer",
                                    "default" : 4096,
                                    "description" : "The size threshold that dictates whether String and binary values should be stored in the binary store. String and binary values smaller than this value are stored with the node, whereas string and binary values with a size equal to or greater than this limit will be stored separately from the node and in the binary store, keyed by the SHA-1 hash of the value. This is a space and performance optimization that stores each unique large value only once. The default value is '4096' bytes, or 4 kilobytes."
                                },
                            }
                        },
                        {
                            "type" : "object",
                            "additionalProperties" : false,
                            "properties" : {
                                "type" : {
                                    "type" : "string",
                                    "description" : "The specification of the database binary store, which stores BINARY values in a JDBC-compatible database.",
                                    "enum" : [ "database" ]
                                },
                                "dataSourceJndiName" : {
                                    "type" : "string",
                                    "description" : "The name in JNDI where the JDBC DataSource is registered that should be used for binary storage.",
                                    "required" : true,
                                },
                                "minimumBinarySizeInBytes" : {
                                    "type" : "integer",
                                    "default" : 4096,
                                    "description" : "The size threshold that dictates whether String and binary values should be stored in the binary store. String and binary values smaller than this value are stored with the node, whereas string and binary values with a size equal to or greater than this limit will be stored separately from the node and in the binary store, keyed by the SHA-1 hash of the value. This is a space and performance optimization that stores each unique large value only once. The default value is '4096' bytes, or 4 kilobytes."
                                },
                            }
                        },
                        {
                            "type" : "object",
                            "additionalProperties" : false,
                            "properties" : {
                                "type" : {
                                    "type" : "string",
                                    "description" : "The specification of the database binary store, which stores BINARY values in a JDBC-compatible database.",
                                    "enum" : [ "cache" ]
                                },
                                "dataCacheName" : {
                                    "type" : "string",
                                    "required" : true,
                                    "description" : "The name of the Infinispan cache where BINARY values should be stored."
                                },
                                "metadataCacheName" : {
                                    "type" : "string",
                                    "required" : true,
                                    "description" : "The name of the Infinispan cache where BINARY values should be stored."
                                },
                                "cacheConfiguration" : {
                                    "type" : "string",
                                    "description" : "The name of the Infinispan configuration file for creating a new cache manager. If a file could not be found (on the thread context classloader, on the application's classpath, or on the system classpath), then the name is assumed to reference an existing Infinispan CacheContainer instance via a valid JNDI name or as the name of a service as defined by the local environment. If not specified or no such container is found, then the same cache manager used for the content storage will be used."
                                },
                                "minimumBinarySizeInBytes" : {
                                    "type" : "integer",
                                    "default" : 4096,
                                    "description" : "The size threshold that dictates whether String and binary values should be stored in the binary store. String and binary values smaller than this value are stored with the node, whereas string and binary values with a size equal to or greater than this limit will be stored separately from the node and in the binary store, keyed by the SHA-1 hash of the value. This is a space and performance optimization that stores each unique large value only once. The default value is '4096' bytes, or 4 kilobytes."
                                },
                            }
                        },
                    ]
                },
            }
        },
        "workspaces" : {
            "type" : "object",
            "additionalProperties" : false,
            "properties" : {
                "predefined" : {
                    "type" : "array",
                    "uniqueItems" : true,
                    "description" : "The names of the workspaces that are defined to exist."
                },
                "default" : {
                    "type" : "string",
                    "description" : "The name of the workspace that should be used when not specified by calls to login to a Session."
                },
                "allowCreation" : {
                    "type" : "boolean",
                    "default" : true,
                    "description" : "Specifies whether users can create additional workspaces beyond the predefined, system, and default workspaces. The default value is 'true'."
                }
            }
        },
        "security" : {
            "type" : "object",
            "additionalProperties" : false,
            "properties" : {
                "jaas" : {
                    "type" : "object",
                    "description" : "The configuration of the authentication/authorization provider that uses JAAS.",
                    "properties" : {
                        "policyName" : {
                            "type" : "string",
                            "default" : "modeshape-jcr",
                            "description" : "The name of the JAAS policy that should be to validate credentials. If not specified, JAAS authentication is not used."
                        }
                    }
                },
                "anonymous" : {
                    "type" : "object",
                    "description" : "The configuration of the authentication/authorization provider that uses JAAS.",
                    "properties" : {
                        "roles" : {
                            "type" : "array",
                            "default" : [ "readonly","readwrite", "admin"],
                            "items" : {
                                "type" : "string",
                            },
                            "uniqueItems" : true, 
                            "description" : "An array of roles provided for anonymous access. Anonymous logins will be disabled if no value or an empty value is provided."
                        },
                        "username" : {
                            "type" : "string",
                            "default" : "<anonymous>",
                            "description" : "The username that should be used for anonymous users."
                        },
                        "useOnFailedLogin" : {
                            "type" : "boolean",
                            "default" : false,
                            "description" : "Indicates whether a failed attempt to authenticate should automatically fall back to attempt to anonymous access instead. If anonymous access is not enabled, then failed login attempts will still cause a LoginException to be thrown. The default value is 'false'."
                        },
                    }
                },
                "providers" : {
                    "type" : "array",
                    "description" : "The named set of security provider configurations",
                    "items" : {
                        "type" : "object",
                        "description" : "Specification of a security provider configuration.",
                        "additionalProperties" : true,
                        "properties" : {
                            "type" : {
                                "type" : "string",
                                "required" : true,
                                "description" : "The fully-qualified name of the 'org.modeshape.jcr.security.AuthenticationProvider' implementation class. Aliases can be used for the built-in providers: 'jaas' for the JAAS provider, and 'servlet' for the Servlet provider."
                            },
                            "classloader" : {
                                "type" : "string",
                                "description" : "The optional name of the classloader that should be used to load the AuthenicationProvider implementation class. If empty or not provided, the classpath accessible to ModeShape will be used."
                            },
                            "name" : {
                                "type" : "string",
                                "description" : "The optional unqiue name of the security provider configuration, used for administration and reporting. If not specified, the classname will be used."
                            }
                        }
                    }
                }
            }
        },
        "query" : {
            "type" : "object",
            "additionalProperties" : false,
            "description" : "The specification of the configuration options for the query system.",
            "properties" : {
                "enabled" : {
                    "type" : "boolean",
                    "default" : true,
                    "description" : "A boolean flag that specifies whether this repository is expected to execute searches and queries. If client applications will never perform searches or queries, then maintaining the query indexes is an unnecessary overhead, and can be disabled. Note that this is merely a hint, and that searches and queries might still work when this is set to 'false'."
                },
                "rebuildUponStartup" : {
                    "type" : "string",
                    "enum" : ["if_missing","always"],
                    "default" : "if_missing",
                    "description" : "Specifies whether the indexes need to be rebuilt immediately when each ModeShape process starts up."
                },
                "extractors" : {
                    "type" : "array",
                    "description" : "An array of extractor configurations.",
                    "items" : {
                        "type" : "object",
                        "description" : "Specification of a text extractor configuration.",
                        "additionalProperties" : true,
                        "properties" : {
                            "type" : {
                                "type" : "string",
                                "required" : true,
                                "description" : "The fully-qualified name of the 'org.modeshape.jcr.text.TextExtractor' implementation class. A shortcut for built-in extractors is to just specify the name of the class (without the package specifciation)."
                            },
                            "classloader" : {
                                "type" : "string",
                                "description" : "The optional name of the classloader that should be used to load the extract class. If empty or not provided, the classpath accessible to ModeShape will be used."
                            },
                            "name" : {
                                "type" : "string",
                                "description" : "The optional unique name of the extractor configuration, used for administration and reporting purposes. If not specified, the extractor's classname will be used."
                            }
                        }
                    }
                },
                "indexStorage" : {
                    "description" : "The specification of where and how the indexes are to be stored. The value is a single nested document, with a required 'type' property (with values of 'ram', 'filesystem', 'filesystem-master', 'filesystem-slave', 'infinispan', or 'custom') and additional properties that are dictated by the 'type' value. If not specified, 'ram' storage will be used.",
                    "type" : [ 
                        {
                            "type" : "object",
                            "description" : "The specification for storing indexes for a non-clustered repository in local memory.",
                            "additionalProperties" : false,
                            "properties" : {
                                "type" : {
                                    "type" : "string",
                                    "enum" : ["ram"],
                                    "required" : true,
                                    "description" : "The specification of the in-memory storage type."
                                }
                            }
                        },
                        {
                            "type" : "object",
                            "description" : "The specification for storing indexes for a (clustered or non-clustered) repository on the local filesystem.",
                            "additionalProperties" : false,
                            "properties" : {
                                "type" : {
                                    "type" : "string",
                                    "description" : "The specification of the local filesystem storage type.",
                                    "required" : true,
                                    "enum" : ["filesystem"]
                                },
                                "location" : {
                                    "type" : "string",
                                    "required" : true,
                                    "description" : "The path on the file system of the directory where the indexes are to be stored."
                                },
                                "lockingStrategy" : {
                                    "type" : "string",
                                    "enum" : [ "simple", "native", "single", "none" ],
                                    "default" : "native",
                                    "description" : "Species the type of locking used to prevent concurrent writes to the indexes. The default locking strategy works well for most cases. If set to 'simple', a marker file will be created using the Java File API (this file may need to be manually removed if the process is terminated abormally). If set to 'native' (the default), a marker file will be created using native OS file locks (which will never need to be cleaned up). If set to 'single', an in-memory Java object is used for the lock, and therefore not useful in a clustered repository. If 'none' is used, no locking is used to prevent concurrent writes (use with caution)."
                                },
                                "fileSystemAccessType" : {
                                    "type" : "string",
                                    "enum" : [ "auto", "simple", "nio", "mmap" ],
                                    "default" : "auto",
                                    "description" : "Specifies the exact type of Lucene FSDirectory implementation to be used. If set to 'auto' (the default), NIOFSDirectory will be used on non Windows systems and SimpleFSDirectory will be used on Windows. If set to 'simple', then SimpleFSDirectory will be used. If set to 'nio', then NIOFSDirectory will be used. If set to 'mmap', then MMapDirectory will be used. Make sure to refer to Javadocs of these Directory implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory can bring substantial performace boosts they also have constraints and limitations."
                                }
                            }
                        },
                        {
                            "type" : "object",
                            "description" : "The specification for storing the master (writable) indexes for a clustered repository (typically when using the JMS backend for updating indexes). Other processes in the cluster will be configured with 'filesystem-slave'. Like 'filesystem', except that a copy of the indexes is made to 'sourceLocation'.",
                            "additionalProperties" : false,
                            "properties" : {
                                "type" : {
                                    "type" : "string",
                                    "description" : "The specification of the master filesystem storage type.",
                                    "required" : true,
                                    "enum" : ["filesystem-master"]
                                },
                                "location" : {
                                    "type" : "string",
                                    "required" : true,
                                    "description" : "The path on the local file system of the directory where the indexes are to be stored for local use."
                                },
                                "lockingStrategy" : {
                                    "type" : "string",
                                    "enum" : [ "simple", "native", "single", "none" ],
                                    "default" : "native",
                                    "description" : "Specifies the type of locking used to prevent concurrent writes to the indexes. The default locking strategy works well for most cases. If set to 'simple', a marker file will be created using the Java File API (this file may need to be manually removed if the process is terminated abormally). If set to 'native' (the default), a marker file will be created using native OS file locks (which will never need to be cleaned up). If set to 'single', an in-memory Java object is used for the lock, and therefore not useful in a clustered repository. If 'none' is used, no locking is used to prevent concurrent writes (use with caution)."
                                },
                                "fileSystemAccessType" : {
                                    "type" : "string",
                                    "enum" : [ "auto", "simple", "nio", "mmap" ],
                                    "default" : "auto",
                                    "description" : "Specifies the exact type of Lucene FSDirectory implementation to be used. If set to 'auto' (the default), NIOFSDirectory will be used on non Windows systems and SimpleFSDirectory will be used on Windows. If set to 'simple', then SimpleFSDirectory will be used. If set to 'nio', then NIOFSDirectory will be used. If set to 'mmap', then MMapDirectory will be used. Make sure to refer to Javadocs of these Directory implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory can bring substantial performace boosts they also have constraints and limitations."
                                },
                                "sourceLocation" : {
                                    "type" : "string",
                                    "required" : true,
                                    "description" : "The path on the (remote) file system of the directory to which the copy is to be written. This must not be the same directory as 'location'."
                                },
                                "refreshInSeconds" : {
                                    "type" : "integer",
                                    "default" : 3600,
                                    "minimum" : 0,
                                    "description" : "The number of seconds specifying the frequency of copying the master index into the 'sourceLocation' directory. The copy is incremental, so it only copies the changes since the last copy. The recommended value for the refresh period is (at least) 50% higher that the time to copy the information, and defaults to 3600 seconds - 60 minutes."
                                }
                            }
                        },
                        {
                            "type" : "object",
                            "description" : "The specification for storing the slave (read-only) indexes for a clustered repository (typically when using the JMS backend for updating indexes). One process in the cluster will be configured with 'filesystem-master', while rest with 'filesystem-slave'.",
                            "additionalProperties" : false,
                            "properties" : {
                                "type" : {
                                    "type" : "string",
                                    "required" : true,
                                    "description" : "The specification of the slave filesystem storage type.",
                                    "enum" : ["filesystem-slave"]
                                },
                                "location" : {
                                    "type" : "string",
                                    "required" : true,
                                    "description" : "The path on the local file system of the directory where the indexes are to be stored for local use."
                                },
                                "lockingStrategy" : {
                                    "type" : "string",
                                    "enum" : [ "simple", "native", "single", "none" ],
                                    "default" : "native",
                                    "description" : "Species the type of locking used to prevent concurrent writes to the indexes. The default locking strategy works well for most cases. If set to 'simple', a marker file will be created using the Java File API (this file may need to be manually removed if the process is terminated abormally). If set to 'native' (the default), a marker file will be created using native OS file locks (which will never need to be cleaned up). If set to 'single', an in-memory Java object is used for the lock, and therefore not useful in a clustered repository. If 'none' is used, no locking is used to prevent concurrent writes (use with caution)."
                                },
                                "fileSystemAccessType" : {
                                    "type" : "string",
                                    "enum" : [ "auto", "simple", "nio", "mmap" ],
                                    "default" : "auto",
                                    "description" : "Specifies the exact type of Lucene FSDirectory implementation to be used. If set to 'auto' (the default), NIOFSDirectory will be used on non Windows systems and SimpleFSDirectory will be used on Windows. If set to 'simple', then SimpleFSDirectory will be used. If set to 'nio', then NIOFSDirectory will be used. If set to 'mmap', then MMapDirectory will be used. Make sure to refer to Javadocs of these Directory implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory can bring substantial performace boosts they also have constraints and limitations."
                                },
                                "sourceLocation" : {
                                    "type" : "string",
                                    "required" : true,
                                    "description" : "The path on the (remote) file system of the directory from which the copy is to be read. This must not be the same directory as 'location'."
                                },
                                "refreshInSeconds" : {
                                    "type" : "integer",
                                    "default" : 3600,
                                    "minimum" : 0,
                                    "description" : "The number of seconds specifying the frequency of copying the index in the 'location' directory into the 'sourceLocation' directory. The copy is incremental, so it only copies the changes since the last copy. The recommended value for the refresh period is (at least) 50% higher that the time to copy the information, and defaults to 3600 seconds - 60 minutes."
                                },
                                "copyBufferSizeInMegabytes" : {
                                    "type" : "integer",
                                    "exclusiveMinimum" : 0,
                                    "default" : 16,
                                    "description" : "The number of megabytes to move in a single low level copy instruction. The default is '16' (or 16MB)."
                                },
                                "retryMarkerLookup" : {
                                    "type" : "integer",
                                    "minimum" : 0,
                                    "default" : 0,
                                    "description" : "The number of times to look for the marker files in the source directory before failing, waiting 5 seconds between each try. The default is '0'."
                                },
                                "retryInitializePeriodInSeconds" : {
                                    "type" : "integer",
                                    "minimum" : 0,
                                    "default" : 0,
                                    "description" : "The number of seconds before retrying initialization. If the slave can't find the master index, it will try again (in the background) until it's found, without preventing the application to start. Queries performed before the index is initialized are not blocked but will return empty results. A value of '0' is used by default, signaling that initialization will fail with an exception rather than trying in the background. To prevent the application from starting without an invalid index but still control an initialization timeout, use 'retryMarkerLookup' instead."
                                }
                            }
                        },
                        {
                            "type" : "object",
                            "description" : "The specification for storing the indexes for a (typically clustered) repository in an Infinispan data grid, making index changes visible to all elements of the cluster very quickly.",
                            "additionalProperties" : false,
                            "properties" : {
                                "type" : {
                                    "type" : "string",
                                    "description" : "The specification of the Infinispan index storage type.",
                                    "required" : true,
                                    "enum" : ["infinispan"]
                                },
                                "lockCacheName" : {
                                    "type" : "string",
                                    "description" : "The name of the Infinispan cache where the index locks will be stored. If not provided, the default will be '<repositoryName>-index-locks'."
                                },
                                "dataCacheName" : {
                                    "type" : "string",
                                    "description" : "The name of the Infinispan cache where the index data will be stored. If not provided, the default will be '<repositoryName>-index-data'."
                                },
                                "metadataCacheName" : {
                                    "type" : "string",
                                    "description" : "The name of the Infinispan cache where the index metadata will be stored. If not provided, the default will be '<repositoryName>-index-metadata'."
                                },
                                "cacheConfiguration" : {
                                    "type" : "string",
                                    "description" : "The name of the Infinispan configuration file for creating a new cache manager. If a file could not be found (on the thread context classloader, on the application's classpath, or on the system classpath), then the name is assumed to reference an existing Infinispan CacheContainer instance via a valid JNDI name or as the name of a service as defined by the local environment. If no such container is found, then the cache container used by the 'storage' configuration is used."
                                },
                                "chunkSizeInBytes" : {
                                    "type" : "integer",
                                    "exclusiveMinimum" : 0,
                                    "default" : 16834,
                                    "description" : "The maximum size in bytes for each chunk of data. Larger sizes offer better search performance but might be problematic during network replication or storage. The default is 16KB, or 16834."
                                }
                            }
                        },
                        {
                            "type" : "object",
                            "description" : "The specification for storing the indexes in a custom directory provider.",
                            "additionalProperties" : true,
                            "properties" : {
                                "type" : {
                                    "type" : "string",
                                    "description" : "The specification of a custom index storage type.",
                                    "required" : true,
                                    "enum" : ["custom"]
                                },
                                "classname" : {
                                    "type" : "string",
                                    "required" : true,
                                    "description" : "The name of the Hiberate Search 'org.hibernate.search.store.DirectoryProvider' implementation class."
                                },
                                "classloader" : {
                                    "type" : "string",
                                    "description" : "The optional name of the classloader or module that should be used to load the DirectoryProvider implementation class. If empty or not provided, the classpath accessible to ModeShape will be used."
                                }
                            }
                        }
                    ]
                },
                "indexing" : {
                    "type" : "object",
                    "additionalProperties" : false,
                    "description" : "The configuration settings controlling how the search indexes are created and maintained.",
                    "properties" : {
                        "threadPool" : {
                            "type" : "string",
                            "default" : "modeshape-workers",
                            "description" : "Name of the thread pool that should be used for background re-indexing. Thread pools are named globally within a single ModeShape engine, and by default all repositories use the same thread pool for sequencing and indexing."
                        },
                        "analyzer" : {
                            "type" : "string",
                            "default" : "org.apache.lucene.analysis.standard.StandardAnalyzer",
                            "description" : "Advanced setting that specifies the fully-qualified name of the 'org.apache.lucene.analysis.Analyzer' implementation class that should be used to extract search terms from text."
                        },
                        "analyzerClassloader" : {
                            "type" : "string",
                            "description" : "The optional name of the classloader or module that should be used to load the analyzer implementation class. If empty or not provided, the classpath accessible to ModeShape will be used."
                        },
                        "similarity" : {
                            "type" : "string",
                            "default" : "org.apache.lucene.search.DefaultSimilarity",
                            "description" : "Advanced setting that specifies the fully-qualified name of the 'org.apache.lucene.search.Similarity' implementation class that should be used for scoring (determining the similarity of terms). The 'org.apache.lucene.search.DefaultSimilarity' class is used by default."
                        },
                        "batchSize" : {
                            "type" : "integer",
                            "default" : -1,
                            "description" : "Advanced setting that specifies the maximum number of indexing operation batched per transaction. Once the limit is reached indexing will be triggered even though the context has not ended yet. A value of '-1' implies no maximum size."
                        },
                        "indexFormat" : {
                            "type" : "string",
                            "pattern" : "LUCENE_(3[0-9]{1,2}|CURRENT)",
                            "default" : "LUCENE_CURRENT",
                            "description" : "Specifies the Lucene version defining the format of the indexes. The default value is 'LUCENE_CURRENT', but for production uses it should be explicitly set to the specific Lucene version used when first creating the versions; changing this value will require a manual rebuilt of all indexes."
                        },
                        "readerStrategy" : {
                            "type" : "string",
                            "enum" : [ "shared", "not-shared" ],
                            "default" : "shared",
                            "description" : "Advanced setting that defines whether Lucene index readers can be shared. With the 'shared' strategy, the same IndexReader will be used (for a given Lucene index) across multiple queries and threads, provided that the IndexReader is still up-to-date. If the IndexReader is not up-to-date, a new one is opened and provided. With the 'not-shared' strategy, a new IndexReader is opened every time a query is executed, which can be expensive."
                        },
                        "mode" : {
                            "type" : "string",
                            "enum" : [ "sync", "async" ],
                            "default" : "sync",
                            "description" : "Specifies whether to apply the index changes synchronously or asynchronously (in separate threads). Synchronous updates have the advantage that the index is at all times in sync with the storec content. Asynchronous updates, on the other hand, can help to minimize Session.save() times since index updates are executed in the background, but may result in potential discrepancies between the saved changes and query results."
                        },
                        "asyncThreadPoolSize" : {
                            "type" : "integer",
                            "default" : 1,
                            "minimum" : 1,
                            "description" : "Specifies the number of threads that may be used for asynchronous application of updates. Defaults to '1', and is not used for synchronous updates."
                        },
                        "asyncMaxQueueSize" : {
                            "type" : "integer",
                            "default" : 1,
                            "minimum" : 0,
                            "description" : "Specifies the maximum size of the queue used for making asynchronous updates. When the queue is filled, updates block until the queue catches up. A value of '0' is the default and implies no limit to the queue size."
                        },
                        "backend" : {
                            "description" : "The specification of options for how the indexes are to be updated. The value is a single nested document, with a required 'type' property (with values of 'lucene', 'jms-backend', 'jgroups-master', 'jgroups-slave', 'blackhold', or 'custom') and additional properties that are dictated by the 'type' value. If not specified, 'lucene' storage will be used.",
                            "type" : [ 
                                {
                                    "type" : "object",
                                    "description" : "The specification for writing all updates directly to Lucene. This is the default and works well for non-clustered repositories. It can also work for clustered repositories, but requires an index storage type that supports locking.",
                                    "additionalProperties" : false,
                                    "properties" : {
                                        "type" : {
                                            "type" : "string",
                                            "enum" : ["lucene"],
                                            "required" : true,
                                            "description" : "The specification of the Lucene backend for writing all updates directly to Lucene."
                                        }
                                    }
                                },
                                {
                                    "type" : "object",
                                    "description" : "The specification for pulling all index updates from a JMS queue and writing them to a local Lucene backend. Index updates originating locally are directly written to Lucene. This is only useful for clustered repositories, where other processes in the cluster are configured with 'jms-slave'. Extra properties will be used to initialize the JNDI InitialContext.",
                                    "additionalProperties" : true,
                                    "properties" : {
                                        "type" : {
                                            "type" : "string",
                                            "enum" : ["jms-master"],
                                            "required" : true,
                                            "description" : "The specification of the JMS master backend."
                                        },
                                        "connectionFactoryJndiName" : { 
                                            "type" : "string",
                                            "required" : true,
                                            "description" : "Defines the name in JNDI where the JMS connection factory can be found. The value is often '/ConnectionFactory' by default in JBoss AS.",
                                        },
                                        "queueJndiName" : { 
                                            "type" : "string",
                                            "required" : true,
                                            "description" : "Defines the name in JNDI where JMS queue can be found. The queue will be used to post work messages.",
                                        }
                                    }
                                }
                                {
                                    "type" : "object",
                                    "description" : "The specification for sending all index updates to a JMS queue, where the master writing all updates directly to Lucene.  This is only useful for clustered repositories, where one other processes in the cluster is configured with 'jms-master'. Extra properties will be used to initialize the JNDI InitialContext.",
                                    "additionalProperties" : true,
                                    "properties" : {
                                        "type" : {
                                            "type" : "string",
                                            "enum" : ["jms-slave"],
                                            "required" : true,
                                            "description" : "The specification of the Lucene backend for writing all updates directly to Lucene."
                                        },
                                        "connectionFactoryJndiName" : { 
                                            "type" : "string",
                                            "required" : true,
                                            "description" : "Defines the name in JNDI where the JMS connection factory can be found. The value is often '/ConnectionFactory' by default in JBoss AS.",
                                        },
                                        "queueJndiName" : { 
                                            "type" : "string",
                                            "required" : true,
                                            "description" : "Defines the name in JNDI where JMS queue can be found. The queue will be used to post work messages.",
                                        }
                                    }
                                },
                                {
                                    "type" : "object",
                                    "description" : "The specification for pulling all index updates from a JGroups channel and writing them to a local Lucene backend. This is only useful for clustered repositories, where other processes in the cluster are configured with 'jgroups-slave'.",
                                    "additionalProperties" : false,
                                    "properties" : {
                                        "type" : {
                                            "type" : "string",
                                            "enum" : ["jgroups-master"],
                                            "required" : true,
                                            "description" : "The specification of the Lucene backend for writing all updates directly to Lucene."
                                        },
                                        "channelName" : { 
                                            "type" : "string",
                                            "required" : true,
                                            "description" : "The name of the JGroups channel used for indexing updates."
                                        },
                                        "channelConfiguration" : { 
                                            "type" : "string",
                                            "required" : true,
                                            "description" : "The JGroups channel configuration. The value can either be the path to a resource file on the classpath, or a value containing the JGroups configuration (in either XML or old-style format)."
                                        }
                                    }
                                },
                                {
                                    "type" : "object",
                                    "description" : "The specification for sending all index updates to the maste through a JGroups channel. This is only useful for clustered repositories, where one other process in the cluster is configured with 'jgroups-master'. ",
                                    "additionalProperties" : false,
                                    "properties" : {
                                        "type" : {
                                            "type" : "string",
                                            "enum" : ["jgroups-slave"],
                                            "required" : true,
                                            "description" : "The specification of the Lucene backend for writing all updates directly to Lucene."
                                        },
                                        "connectionFactoryJndiName" : { 
                                            "type" : "string",
                                            "required" : true,
                                            "description" : "Defines the name in JNDI where the JMS connection factory can be found. The value is often '/ConnectionFactory' by default in JBoss AS.",
                                        },
                                        "queueJndiName" : { 
                                            "type" : "string",
                                            "required" : true,
                                            "description" : "Defines the name in JNDI where JMS queue can be found. The queue will be used to post work messages.",
                                        }
                                    }
                                },
                                {
                                    "type" : "object",
                                    "description" : "The specification for a backend where all index updates are dropped and not processed. This may be useful during development and testing, but should never be used in a staging or production environment.",
                                    "additionalProperties" : false,
                                    "properties" : {
                                        "type" : {
                                            "type" : "string",
                                            "enum" : ["blackhole"],
                                            "required" : true,
                                            "description" : "The specification of the blackhole backend."
                                        },
                                    }
                                },
                                {
                                    "type" : "object",
                                    "description" : "The specification for a custom backend processor.",
                                    "additionalProperties" : true,
                                    "properties" : {
                                        "type" : {
                                            "type" : "string",
                                            "description" : "The specification of a custom backend processor.",
                                            "required" : true,
                                            "enum" : ["custom"]
                                        },
                                        "classname" : {
                                            "type" : "string",
                                            "required" : true,
                                            "description" : "The fully-qualified name of the class that implements the 'org.hibernate.search.backend.spi.BackendQueueProcessor' interface."
                                        },
                                        "classloader" : {
                                            "type" : "string",
                                            "description" : "The optional name of the classloader or module that should be used to load the BackendQueueProcessor implementation class. If empty or not provided, the classpath accessible to ModeShape will be used."
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "patternProperties" : {
                        "hibernate[.]search[.].*" : {
                            "type" : "string",
                            "required" : false,
                            "description" : "Additional properties that follow the 'hibernate.search.*' pattern will override all other properties and will be passed directly to Hibernate Search. These are optional, and should only be used for advanced configuration."
                        }
                    }
                }
            }
        },
        "sequencing" : {
            "type" : "object",
            "description" : "The options for sequencing.",
            "additionalProperties" : false,
            "properties" : {
                "removeDerivedContentWithOriginal" : {
                    "type" : "boolean",
                    "default" : true,
                    "description" : "Boolean option that controls whether the repository should also remove the content automatically derived by sequencers from the original content when that original content is removed. The default is 'true', since often times the derived content should not be kept if the original is being deleted."
                },
                "threadPool" : {
                    "type" : "string",
                    "default" : "modeshape-workers",
                    "description" : "Name of the thread pool that should be used for sequencing. Thread pools are named globally within a single ModeShape engine, and by default all repositories use the same thread pool for sequencing and indexing."
                },
                "sequencers" : {
                    "type" : "array",
                    "description" : "The named set of sequencer configurations",
                    "required" : true,
                    "items" : {
                        "type" : "object",
                        "additionalProperties" : true,
                        "description" : "Specification of a sequencer configuration.",
                        "properties" : {
                            "type" : {
                                "type" : "string",
                                "required" : true,
                                "description" : "The fully-qualified name of the 'org.modeshape.jcr.api.sequencer.Sequencer' subclass. A shortcut for built-in sequencers is to just use the name of the class (without the package specification)."
                            },
                            "classloader" : {
                                "type" : "string",
                                "description" : "The optional name of the classloader that should be used to load the sequencer class. If empty or not provided, the classpath accessible to ModeShape will be used."
                            },
                            "pathExpressions" : {
                                "type" : "array",
                                "required" : true,
                                "items" : {
                                    "type" : "string"
                                },
                                "description" : "The expressions that describes the paths upon which this sequencer operates and the paths where the sequencer output is written."
                            },
                            "name" : {
                                "type" : "string",
                                "description" : "The optional unique name of the sequencer configuration, used for administration and reporting purposes. If not specified, the description will be a combination of the type and path expressions."
                            },
                            "acceptedMimeTypes" : {
                                "type" : "array",
                                "items" : {
                                    "type" : "string",
                                },
                                "uniqueItems" : true, 
                                "description" : "The optional MIME types for the kind of content that this sequencer configuration should process. If not specified, then the sequencer class' default MIME types will be used. Set to an empty array to forcibly allow processing content with any MIME type."
                            }
                        }
                    }
                }
            }
        },
        "clustering" : {
            "type" : "object",
            "description" : "The clustering configuration. If absent, clustering will be disabled",
            "additionalProperties" : true,
            "properties" : {
                "clusterName" : {
                    "type" : "string",
                    "description" : "The name of the cluster to which a JGroups channel will connect",
                    "default" : "ModeShape-JCR"
                },
                "channelProvider" : {
                    "type" : "string",
                    "description" : "The fully qualified class name of a org.modeshape.jcr.clustering.ChannelProvider implementation which is expected to provide a JChannel instance",
                    "default" : "org.modeshape.jcr.clustering.DefaultChannelProvider"
                },
                "channelConfiguration" : {
                    "type" : "string",
                    "description" : "An optional string which represents a JChannel configuration file. Normally, a CDATA wrapped XML section should be used"
                }
            }
        }
    }
}