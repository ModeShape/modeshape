#
# ModeShape (http://www.modeshape.org)
# See the COPYRIGHT.txt file distributed with this work for information
# regarding copyright ownership.  Some portions may be licensed
# to Red Hat, Inc. under one or more contributor license agreements.
# See the AUTHORS.txt file in the distribution for a full listing of 
# individual contributors. 
#
# ModeShape is free software. Unless otherwise indicated, all code in ModeShape
# is licensed to you under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of
# the License, or (at your option) any later version.
#
# ModeShape is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this software; if not, write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301 USA, or see the FSF site: http://www.fsf.org.
#
closedConnectionMayNotBeUsed = The connection has been closed and may not be used
errorConvertingIo = Error converting {0} to a {1}
errorConvertingType = Error converting {0} to a {1}: {2}
errorReadingPropertyValueBytes = Error reading bytes
invalidIndexInSegmentName = Invalid index, "{0}", in segment name: {1}
invalidQualifiedNameString = Unable to parse qualified name from "{0}"
maximumPoolSizeMayNotBeSmallerThanCorePoolSize = The maximum pool size may not be smaller than the core pool size
missingEndBracketInSegmentName = Missing end bracket in segment name: {0}
noNamespaceRegisteredForPrefix = There is no namespace registered for the prefix "{0}"
pathAncestorDegreeIsInvalid = Unable to obtain the {1} ancestor for {0}
pathCannotBeNormalized = The path {0} is invalid and cannot be normalized
pathIsAlreadyAbsolute = The path {0} is already an absolute path
pathIsNotAbsolute = The path {0} is not an absolute path
pathIsNotRelative = The path {0} is not a relative path
repositoryConnectionPoolIsNotRunning = The repository connection pool is not running
unableToCreateSubpathBeginIndexGreaterThanOrEqualToEndingIndex = Unable to create subpath: fromIndex({0}) >= toIndex({1})
unableToCreateSubpathBeginIndexGreaterThanOrEqualToSize = Unable to create subpath: fromIndex({0}) >= size({1})
unableToCreateValue = Unable to create {0} value from {1} "{2}": undefined type conversion
unableToDiscoverPropertyTypeForNullValue = Unable to discover property type for null value
unableToObtainValidRepositoryAfterAttempts = Unable to obtain a valid repository after {0} attempts
validPathMayNotContainEmptySegment = The path "{0}" is not valid because it contains an empty segment
valueJavaTypeNotCompatibleWithPropertyType = Value is instance of Java type "{0}" and is not compatible with the "{1}" property type
pathExpressionMayNotBeBlank = The path expression may not be blank
pathExpressionIsInvalid = The path expression {0} is not valid
pathExpressionHasInvalidSelect = Invalid select expression "{0}" in the path expression "{1}"
pathExpressionHasInvalidMatch = Invalid match expression "{0}" in the path expression "{1}"
messageDigestNotFound = The "{0}" message digest algorithm could not be found
pathNotFoundExceptionLowestExistingLocationFound = Unable to find "{0}"; lowest existing path is "{1}"

executingRequest = Executing {0}
executedRequest = Executed {0}
closingRequestProcessor = Closing request processor
closedRequestProcessor = Closed request processor
multipleErrorsWhileExecutingManyRequests = {0} of the many requests resulted in errors: {1}
multipleErrorsWhileExecutingRequests = {0} of the {1} requests resulted in errors: {2}
errorWhilePerformingAccessQuery = Error while performing the access query "{0}" against the content in the "{1}" workspace of the "{2}" source: {3}
unsupportedRequestType = Requests of type "{0}" are unsupported; actual request was to {1}
unableToAddMoreRequestsToAlreadyExecutedBatch = Unable to add more requests to a batch of graph requests that has already been executed
unableToCreateReferenceToNodeWithoutUuid = Unable to set a reference to node {0} since it has no UUID
unableToCopyToLocationWithoutAPath = Unable to copy node "{0}" to "{1}" since the desired location has no path
unableToCopyToTheRoot = Unable to copy node "{0}" to "{1}" since the desired location is the root node
actualLocationNotEqualToInputLocation = The actual location of {0} is not equal to the current location of {1}
actualLocationIsNotChildOfInputLocation = The actual location of {0} is not a child of the specified location {1}
actualLocationIsNotAtCorrectChildSegment = The last segment of the actual location of {0} does not have the requested child segment {1}
actualLocationDoesNotHaveCorrectChildName = The last segment of the actual location of {0} does not have the requested child name {1}
actualLocationMustHavePath = The actual location of {0} must have a path
actualNewLocationIsNotSameAsInputLocation = The actual new location of {0} is not the same as the input location of {1}
actualNewLocationMustHavePath = The actual new location of {0} must have a path
actualOldLocationIsNotSameAsInputLocation = The actual old location of {0} is not the same as the input location of {1}
actualOldLocationMustHavePath = The actual old location of {0} must have a path
actualNewLocationMustHaveSameParentAsOldLocation = The new location of {0} must be a sibling of the old location of {1}
actualNewLocationMustHaveSameNameAsRequest = The new location of {0} must have the same name as in the request ({1})
requestIsFrozenAndMayNotBeChanged = Request is frozen and may not be changed: {0}
propertyIsNotPartOfRequest = The "{0}" property is not part of the request: {1}

errorImportingContent = Error importing {0} content from {1}
unableToFindRepositorySourceWithName = Unable to find a repository source named "{0}"
nodeAlreadyExistsWithUuid = A node with UUID "{0}" already exists at path "{1}" in workspace "{2}"
couldNotAcquireLock = Could not acquire lock on the node at "{0}" in workspace "{1}"

errorNotifyingObserver = Error notifying observer: {0}

# In-memory connector
nodeDoesNotExist = Could not find an existing node at {0}
errorSerializingInMemoryCachePolicyInSource = Error serializing a {0} instance owned by the {1} in-memory repository
inMemoryConnectorRequestsMustHavePathOrUuid = In-Memory connector can only process requests with a path and/or UUID
inMemoryConnectorMustAllowUpdates = In-Memory connector "{0}" must allow updates.  
pathConnectorRequestsMustHavePath = Path connectors can only process requests with a path
workspaceDoesNotExistInRepository = The workspace "{0}" does not exist in the "{1}" repository
workspaceAlreadyExistsInRepository = The workspace "{0}" already exists in the "{1}" repository
sourceIsReadOnly = The repository source "{0}" does not allow updates.  Set the "updatesAllowed" property to "true" on the repository source to allow updates.
workspaceIsReadOnly = The workspace "{1}" in repository source "{0}" does not allow updates.  Setting the "updatesAllowed" property to "true" on the repository source may allow this workspace to support updates. 

# Federation connector
namePropertyIsRequiredForFederatedRepositorySource = The "{0}" property is required on each federated repository source
propertyIsRequiredForFederatedRepositorySource = The "{0}" property is required on the "{1}" federated repository source
federatedRepositorySourceMustBeInitialized = The "{0}" federated repository source must be initialized before it can be used
errorReadingConfigurationForFederatedRepositorySource = Error with the "{0}" federated repository source's configuration
errorAddingProjectionRuleParseMethod = Error while adding a parsing method for a federation projection rule
requiredNodeDoesNotExistRelativeToNode = The required node "{0}" does not exist relative to "{1}" in "{2}" workspace of the "{3}" repository
unableToObtainConnectionToFederatedSource = Unable to obtain a connection to source "{0}" being federated by the "{1}" workspace of the "{2}" federated repository
workspaceDoesNotExistInFederatedRepository = The workspace "{0}" does not exist in the "{1}" federated repository
locationCannotBeProjectedIntoWorkspaceAndSource = {0} does not exist in the "{1}" workspace of the "{2}" federated repository
unableToAddRequestToChannelThatIsDone = Unable to add a request to the "{0}" channel since it is done: {1}
federatedSourceDoesNotSupportCreatingWorkspaces = {0} is a source that does not allow creating workspaces
federatedSourceDoesNotSupportCloningWorkspaces = {0} is a source that does not allow cloning workspaces
federatedSourceDoesNotSupportDestroyingWorkspaces = {0} is a source that does not allow destroying workspaces
unableToProjectSourceInformationIntoWorkspace = Unable to project source information at {0} in the "{1} federated repository source using projection {2}
unableToCreateNodeUnderPlaceholder = Unable to create node "{0}" under {1} in the "{2}" workspace of the "{3}" federarted repository because the parent is a placeholder
unableToUpdatePlaceholder = Unable to update node {0} in the "{1}" workspace of the "{2}" federarted repository because the node is a placeholder
unableToDeletePlaceholder = Unable to delete node {0} in the "{1}" workspace of the "{2}" federarted repository because the node is a placeholder
copyLimitedToBeWithinSingleSource = Unable to copy {0} in the "{1}" workspace of the "{3}" federarted repository into {2} in the "{3}" workspace: copy is only supported when the original and new locations are within the same source
moveLimitedToBeWithinSingleSource = Unable to move {0} in the "{1}" workspace of the "{3}" federarted repository into {2} in the "{3}" workspace: move is only supported when the original and new locations are within the same source
cloneLimitedToBeWithinSingleSource = Unable to clone {0} in the "{1}" workspace of the "{3}" federated repository into {2} in the "{3}" workspace: clone is only supported when the original and new locations are within the same source

# Session 
unableToRefreshBranchBecauseChangesDependOnChangesToNodesOutsideOfBranch = Unable to refresh "{0}" in workspace "{1}" because it contains changes that depend on changes to nodes outside of this branch
unableToSaveBranchBecauseChangesDependOnChangesToNodesOutsideOfBranch = Unable to save "{0}" in workspace "{1}" because it contains changes that depend on changes to nodes outside of this branch
unableToSaveNodeThatWasCreatedSincePreviousSave = Unable to save node "{0}" in workspace "{1}" because it was created since the last save
nodeHasAlreadyBeenRemovedFromThisSession = Node "{0}" in workspace "{1} has already been removed from this session
unableToMoveNodeToBeChildOfDecendent = Node "{0}" in workspace "{2}" cannot be moved under a decendant node ("{1}") 
childNotFound = Child "{0}" could not be found under "{1}" in workspace "{2}" 

# Query
unknownQueryLanguage = '{0}' is not a known query language
tableDoesNotExist = Table '{0}' does not exist
columnDoesNotExistOnTable = Column '{0}' does not exist on the table '{1}'
columnDoesNotExistInQuery = Column '{0}' does not exist in query
columnIsNotFullTextSearchable = Column '{0}' on the table '{1}' does not support full-text searching
tableIsNotFullTextSearchable = Table '{0}' has no columns that support full-text searching
columnTypeCannotBeUsedInArithmeticOperation = Column '{0}' on table '{1}' has a type of '{2}' and cannot be used in an arithmetic operation
dynamicOperandCannotBeUsedInArithmeticOperation = '{0}' does not evaluate to a long or double and cannot be used in an arithmetic operation
selectorDoesNotExistInQuery = Selector '{0}' does not exist in query
propertyOnSelectorIsNotUsedInQuery = Property '{0}' on selector '{1}' is not used in query
errorResolvingNodesFromLocationsUsingSourceAndWorkspace = Error resolving nodes from locations using '{1}' workspace in '{0}'
queryHasNoResults = The query has no results
schemataKeyReferencesNonExistingColumn = Schemata key for table '{0}' references a non-existant column '{1}'
nextMethodMustBeCalledBeforeGettingValue = The 'next()' method must be called before 'getValue()'
expectingValidName = Expecting a valid name but found '{0}'
expectingValidPath = Expecting a valid path but found '{0}'
columnMustBeScoped = Column '{0}' must be scoped
expectingValidNameAtLineAndColumn = Expecting a valid name but found '{0}' at line {1}, column {2}
expectingValidPathAtLineAndColumn = Expecting a valid path but found '{0}' at line {1}, column {2}
mustBeScopedAtLineAndColumn = '{0}' must be scoped at line {1}, column {2}
unexpectedToken = Unexpected token '{0}' at line {1}, column {2}
secondValueInLimitRangeCannotBeLessThanFirst = Second value {0} in LIMIT range cannot be less the first value {1} at line {2}, column {3}
expectingComparisonOperator = Expecting '=', '<>', '!=', '<', '<=', '>', '>=', or 'LIKE' but found '{0}' at line {1}, column {2}
expectingConstraintCondition = Expecting a constraint, but found '{0}' at line {1}, column {2}
functionIsAmbiguous = The {0} function at line {1}, column {2} is ambiguous since there is more than one selector
bindVariableMustConformToNcName = The name of a variable must conform to a valid NCName, but found '{0}' at line {1}, column {2}
invalidPropertyType = Expecting 'STRING', 'BINARY', 'DATE', 'LONG', 'DOUBLE', 'DECIMAL', 'BOOLEAN', 'NAME', 'PATH', 'REFERENCE', 'WEAKREFERENCE', or 'URI', but found '{0}' at line {1}, column {2}
valueCannotBeCastToSpecifiedType = The literal value '{0}' at line {1}, column {2} cannot be cast to a {3} type: {4}
noMatchingBracketFound = No matching closing bracket for the one at line {0}, column {1}
expectingLiteralAndUnableToParseAsLong = Expecting literal and unable to parse '{0}' at line {1}, column {2} as a long
expectingLiteralAndUnableToParseAsDouble = Expecting literal and unable to parse '{0}' at line {1}, column {2} as a double
expectingLiteralAndUnableToParseAsDate = Expecting literal and unable to parse '{0}' at line {1}, column {2} as a date
unexpectedClosingParenthesis = Unexpected closing parenthesis without a matching opening parenthesis

# Search
interruptedWhileClosingChannel = Thread was interrupted while closing request processing channel for source "{0}"
errorWhilePerformingQuery = Error while performing the query "{0}" against the content in the "{1}" workspace of the "{2}" source: {3}
errorShuttingDownExecutorServiceInSearchEngineIndexer = Error shutting down the executor service in the search engine indexer for the search engine using the "{0}" source
searchEngineIndexerForSourceHasAlreadyBeenClosed = The search engine indexer for the "{0}" source has already been closed and cannot be used
