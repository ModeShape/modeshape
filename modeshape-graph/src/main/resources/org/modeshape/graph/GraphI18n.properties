#
# ModeShape (http://www.modeshape.org)
# See the COPYRIGHT.txt file distributed with this work for information
# regarding copyright ownership.  Some portions may be licensed
# to Red Hat, Inc. under one or more contributor license agreements.
# See the AUTHORS.txt file in the distribution for a full listing of 
# individual contributors. 
#
# ModeShape is free software. Unless otherwise indicated, all code in ModeShape
# is licensed to you under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of
# the License, or (at your option) any later version.
#
# ModeShape is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this software; if not, write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301 USA, or see the FSF site: http://www.fsf.org.
#
closedConnectionMayNotBeUsed = The connection has been closed and may not be used
errorConvertingIo = Error converting {0} to a {1}
errorConvertingType = Error converting {0} to a {1}: {2}
errorReadingPropertyValueBytes = Error reading bytes
invalidIndexInSegmentName = Invalid index, "{0}", in segment name: {1}
invalidQualifiedNameString = Unable to parse qualified name from "{0}"
maximumPoolSizeMayNotBeSmallerThanCorePoolSize = The maximum pool size may not be smaller than the core pool size
missingEndBracketInSegmentName = Missing end bracket in segment name: {0}
noNamespaceRegisteredForPrefix = There is no namespace registered for the prefix "{0}"
pathAncestorDegreeIsInvalid = Unable to obtain the {1} ancestor for {0}
pathCannotBeNormalized = The path {0} is invalid and cannot be normalized
pathIsAlreadyAbsolute = The path {0} is already an absolute path
pathIsNotAbsolute = The path {0} is not an absolute path
pathIsNotRelative = The path {0} is not a relative path
identifierPathContainedUnsupportedIdentifierFormat = The identifier path "{0}" does not contain a known identifier format
identifierPathDoesNotMatchSuppliedUuid = The identifier path "{0}" does not match the supplied UUID "{1}"
unableToResolvePathRelativeToIdentifierPath = Unable to resolve the path '{0}' relative to the identifier path '{1}'
unableToCreateRelativePathWithIdentifierSegment = Unable to create a relative path using one or more identifier segments: '{0}'. Identifier paths are always absolute.
unableToCreatePathBasedUponIdentifierPath = Unable to create a path using the identifier path '{0}' as the parent and the segment: '{1}'. Identifier paths may only contain a single identifier segment.
unableToCreatePathUsingIdentifierPathAndAnotherPath = Unable to create a path with the identifier segment '{1}' and the parent path: '{0}'. Identifier paths may only contain a single identifier segment.
repositoryConnectionPoolIsNotRunning = The repository connection pool is not running
unableToCreateSubpathBeginIndexGreaterThanOrEqualToEndingIndex = Unable to create subpath: fromIndex({0}) >= toIndex({1})
unableToCreateSubpathBeginIndexGreaterThanOrEqualToSize = Unable to create subpath: fromIndex({0}) >= size({1})
unableToCreateValue = Unable to create {0} value from {1} "{2}": undefined type conversion
unableToDiscoverPropertyTypeForNullValue = Unable to discover property type for null value
unableToObtainValidRepositoryAfterAttempts = Unable to obtain a valid repository after {0} attempts
validPathMayNotContainEmptySegment = The path "{0}" is not valid because it contains an empty segment
missingClosingBrace = The path "{0}" is not valid because it is missing a closing brace ("}")
valueJavaTypeNotCompatibleWithPropertyType = Value is instance of Java type "{0}" and is not compatible with the "{1}" property type
pathExpressionMayNotBeBlank = The path expression may not be blank
pathExpressionIsInvalid = The path expression {0} is not valid
pathExpressionHasInvalidSelect = Invalid select expression "{0}" in the path expression "{1}"
pathExpressionHasInvalidMatch = Invalid match expression "{0}" in the path expression "{1}"
messageDigestNotFound = The "{0}" message digest algorithm could not be found
pathNotFoundExceptionLowestExistingLocationFound = Unable to find "{0}"; lowest existing path is "{1}"

executingRequest = Executing {0}
executedRequest = Executed {0}
closingRequestProcessor = Closing request processor
closedRequestProcessor = Closed request processor
multipleErrorsWhileExecutingManyRequests = {0} of the many requests resulted in errors: {1}
multipleErrorsWhileExecutingRequests = {0} of the {1} requests resulted in errors: {2}
errorWhilePerformingAccessQuery = Error while performing the access query "{0}" against the content in the "{1}" workspace of the "{2}" source: {3}
unsupportedRequestType = Requests of type "{0}" are unsupported; actual request was to {1}
unableToAddMoreRequestsToAlreadyExecutedBatch = Unable to add more requests to a batch of graph requests that has already been executed
unableToCreateReferenceToNodeWithoutUuid = Unable to set a reference to node {0} since it has no UUID
unableToCopyToLocationWithoutAPath = Unable to copy node "{0}" to "{1}" since the desired location has no path
unableToCopyToTheRoot = Unable to copy node "{0}" to "{1}" since the desired location is the root node
actualLocationNotEqualToInputLocation = The actual location of {0} is not equal to the current location of {1}
actualLocationIsNotChildOfInputLocation = The actual location of {0} is not a child of the specified location {1}
actualLocationIsNotAtCorrectChildSegment = The last segment of the actual location of {0} does not have the requested child segment {1}
actualLocationDoesNotHaveCorrectChildName = The last segment of the actual location of {0} does not have the requested child name {1}
actualLocationMustHavePath = The actual location of {0} must have a path
actualNewLocationIsNotSameAsInputLocation = The actual new location of {0} is not the same as the input location of {1}
actualNewLocationMustHavePath = The actual new location of {0} must have a path
actualOldLocationIsNotSameAsInputLocation = The actual old location of {0} is not the same as the input location of {1}
actualOldLocationMustHavePath = The actual old location of {0} must have a path
actualNewLocationMustHaveSameParentAsOldLocation = The new location of {0} must be a sibling of the old location of {1}
actualNewLocationMustHaveSameNameAsRequest = The new location of {0} must have the same name as in the request ({1})
requestIsFrozenAndMayNotBeChanged = Request is frozen and may not be changed: {0}
propertyIsNotPartOfRequest = The "{0}" property is not part of the request: {1}
namespaceAliasWasNotMappedToRealNamespace = The aliased namespace "{0}" was not mapped to an original namespace
aliasesMappedToRealNamespacesButWereNotRegisteredInAliasNamespace = One or more alias namespaces were mapped to original namespaces but not registered with a prefix in the alias namespace registry: {0}

errorImportingContent = Error importing {0} content from {1}
unableToFindRepositorySourceWithName = Unable to find a repository source named "{0}"
nodeAlreadyExistsWithUuid = A node with UUID "{0}" already exists at path "{1}" in workspace "{2}"
nodeDoesNotExistWithUuid = A node with UUID "{0}" has been locally removed from workspace "{1}"
couldNotAcquireLock = Could not acquire lock on the node at "{0}" in workspace "{1}"

errorNotifyingObserver = Error notifying observer: {0}

# In-memory connector
nodeDoesNotExist = Could not find an existing node at {0}
errorSerializingInMemoryCachePolicyInSource = Error serializing a {0} instance owned by the {1} in-memory repository
inMemoryConnectorRequestsMustHavePathOrUuid = In-Memory connector can only process requests with a path and/or UUID
inMemoryConnectorMustAllowUpdates = In-Memory connector "{0}" must allow updates.  
pathConnectorRequestsMustHavePath = Path connectors can only process requests with a path
workspaceDoesNotExistInRepository = The workspace "{0}" does not exist in the "{1}" repository
workspaceAlreadyExistsInRepository = The workspace "{0}" already exists in the "{1}" repository
currentWorkspaceCannotBeDeleted = The workspace "{0}" is in use and cannot be removed from the "{1}" repository
sourceIsReadOnly = The repository source "{0}" does not allow updates.  Set the "updatesAllowed" property to "true" on the repository source to allow updates.
workspaceIsReadOnly = The workspace "{1}" in repository source "{0}" does not allow updates.  Setting the "updatesAllowed" property to "true" on the repository source may allow this workspace to support updates. 

namePropertyDescription = The name of the repository source, which must be unique within the ModeShape configuration.
namePropertyLabel = Source Name
namePropertyCategory =
rootNodeUuidWithDefaultPropertyDescription = Optional property that defines the UUID of the root node in this repository. If not used, then the 'cafebabe-cafe-babe-cafe-babecafebabe' UUID is used.
rootNodeUuidPropertyDescription = Optional property that defines the UUID of the root node in this repository. If not used, then a new UUID is generated.
rootNodeUuidPropertyLabel = UUID of Root Node
rootNodeUuidPropertyCategory =
jndiNamePropertyDescription = Optional property that specifies the name in JNDI where this repository source is bound. This is an advanced property that is infrequently used.
jndiNamePropertyLabel = Name in JNDI
jndiNamePropertyCategory = Advanced
defaultWorkspaceNamePropertyDescription = Optional property that defines the name for the workspace that will be used by default if none is specified. The default value is an empty string.
defaultWorkspaceNamePropertyLabel = Default Workspace Name
defaultWorkspaceNamePropertyCategory = Workspaces
predefinedWorkspaceNamesPropertyDescription = Optional property that specifies the names of the workspaces that are available at startup. The default value is an an empty array.
predefinedWorkspaceNamesPropertyLabel = Predefined Workspace Names
predefinedWorkspaceNamesPropertyCategory = Workspaces
retryLimitPropertyDescription = Optional property that defines the number of times that any single operation on a connection to this source should be retried following a communication failure. The default value is '0'.
retryLimitPropertyLabel = Retry Limit
retryLimitPropertyCategory = Advanced
updatesAllowedPropertyDescription = Specifies whether the source content can be updated or changed.
updatesAllowedPropertyLabel = Allows Updates
updatesAllowedPropertyCategory = Advanced

# XML File connector
contentPropertyDescription = Specifies the URL, classpath resource path, or file system path for the XML file where this repository source is to find its initial content
contentPropertyLabel = Content Location
contentPropertyCategory = 

# Federation connector
namePropertyIsRequiredForFederatedRepositorySource = The "{0}" property is required on each federated repository source
propertyIsRequiredForFederatedRepositorySource = The "{0}" property is required on the "{1}" federated repository source
federatedRepositorySourceMustBeInitialized = The "{0}" federated repository source must be initialized before it can be used
errorReadingConfigurationForFederatedRepositorySource = Error with the "{0}" federated repository source's configuration
errorAddingProjectionRuleParseMethod = Error while adding a parsing method for a federation projection rule
requiredNodeDoesNotExistRelativeToNode = The required node "{0}" does not exist relative to "{1}" in "{2}" workspace of the "{3}" repository
unableToObtainConnectionToFederatedSource = Unable to obtain a connection to source "{0}" being federated by the "{1}" workspace of the "{2}" federated repository
workspaceDoesNotExistInFederatedRepository = The workspace "{0}" does not exist in the "{1}" federated repository
locationCannotBeProjectedIntoWorkspaceAndSource = {0} does not exist in the "{1}" workspace of the "{2}" federated repository
unableToAddRequestToChannelThatIsDone = Unable to add a request to the "{0}" channel since it is done: {1}
federatedSourceDoesNotSupportCreatingWorkspaces = {0} is a source that does not allow creating workspaces
federatedSourceDoesNotSupportCloningWorkspaces = {0} is a source that does not allow cloning workspaces
federatedSourceDoesNotSupportDestroyingWorkspaces = {0} is a source that does not allow destroying workspaces
unableToProjectSourceInformationIntoWorkspace = Unable to project source information at {0} in the "{1} federated repository source using projection {2}
unableToCreateNodeUnderPlaceholder = Unable to create node "{0}" under {1} in the "{2}" workspace of the "{3}" federarted repository because the parent is a placeholder
unableToUpdatePlaceholder = Unable to update node {0} in the "{1}" workspace of the "{2}" federarted repository because the node is a placeholder
unableToDeletePlaceholder = Unable to delete node {0} in the "{1}" workspace of the "{2}" federarted repository because the node is a placeholder
copyLimitedToBeWithinSingleSource = Unable to copy {0} in the "{1}" workspace of the "{3}" federarted repository into {2} in the "{3}" workspace: copy is only supported when the original and new locations are within the same source
moveLimitedToBeWithinSingleSource = Unable to move {0} in the "{1}" workspace of the "{3}" federarted repository into {2} in the "{3}" workspace: move is only supported when the original and new locations are within the same source
cloneLimitedToBeWithinSingleSource = Unable to clone {0} in the "{1}" workspace of the "{3}" federated repository into {2} in the "{3}" workspace: clone is only supported when the original and new locations are within the same source

# Session 
unableToRefreshBranchBecauseChangesDependOnChangesToNodesOutsideOfBranch = Unable to refresh "{0}" in workspace "{1}" because it contains changes that depend on changes to nodes outside of this branch
unableToSaveBranchBecauseChangesDependOnChangesToNodesOutsideOfBranch = Unable to save "{0}" in workspace "{1}" because it contains changes that depend on changes to nodes outside of this branch
unableToSaveNodeThatWasCreatedSincePreviousSave = Unable to save node "{0}" in workspace "{1}" because it was created since the last save
nodeHasAlreadyBeenRemovedFromThisSession = Node "{0}" in workspace "{1} has already been removed from this session
unableToMoveNodeToBeChildOfDecendent = Node "{0}" in workspace "{2}" cannot be moved under a decendant node ("{1}") 
childNotFound = Child "{0}" could not be found under "{1}" in workspace "{2}" 
unableToRefreshPropertiesBecauseNodeIsModified = Unabled to refresh "{0}" in workspace "{1}" because this node is new or modified

# Query
unknownQueryLanguage = '{0}' is not a known query language
tableDoesNotExist = Table '{0}' does not exist
columnDoesNotExistOnTable = Column '{0}' does not exist on the table '{1}'
columnDoesNotExistInQuery = Column '{0}' does not exist in query
columnIsNotFullTextSearchable = Column '{0}' on the table '{1}' does not support full-text searching
tableIsNotFullTextSearchable = Table '{0}' has no columns that support full-text searching
columnTypeCannotBeUsedInArithmeticOperation = Column '{0}' on table '{1}' has a type of '{2}' and cannot be used in an arithmetic operation
dynamicOperandCannotBeUsedInArithmeticOperation = '{0}' does not evaluate to a long or double and cannot be used in an arithmetic operation
selectorDoesNotExistInQuery = Selector '{0}' does not exist in query
propertyOnSelectorIsNotUsedInQuery = Property '{0}' on selector '{1}' is not used in query
errorResolvingNodesFromLocationsUsingSourceAndWorkspace = Error resolving nodes from locations using '{1}' workspace in '{0}'
queryHasNoResults = The query has no results
schemataKeyReferencesNonExistingColumn = Schemata key for table '{0}' references a non-existant column '{1}'
nextMethodMustBeCalledBeforeGettingValue = The 'next()' method must be called before 'getValue()'
expectingValidName = Expecting a valid name but found '{0}'
expectingValidPath = Expecting a valid path but found '{0}'
columnMustBeScoped = Column '{0}' must be scoped
expectingValidNameAtLineAndColumn = Expecting a valid name but found '{0}' at line {1}, column {2}
expectingValidPathAtLineAndColumn = Expecting a valid path but found '{0}' at line {1}, column {2}
mustBeScopedAtLineAndColumn = '{0}' must be scoped at line {1}, column {2}
unexpectedToken = Unexpected token '{0}' at line {1}, column {2}
secondValueInLimitRangeCannotBeLessThanFirst = Second value {0} in LIMIT range cannot be less the first value {1} at line {2}, column {3}
expectingComparisonOperator = Expecting '=', '<>', '!=', '<', '<=', '>', '>=', or 'LIKE' but found '{0}' at line {1}, column {2}
expectingConstraintCondition = Expecting a constraint, but found '{0}' at line {1}, column {2}
functionIsAmbiguous = The {0} function at line {1}, column {2} is ambiguous since there is more than one selector
bindVariableMustConformToNcName = The name of a variable must conform to a valid NCName, but found '{0}' at line {1}, column {2}
invalidPropertyType = Expecting 'STRING', 'BINARY', 'DATE', 'LONG', 'DOUBLE', 'DECIMAL', 'BOOLEAN', 'NAME', 'PATH', 'REFERENCE', 'WEAKREFERENCE', or 'URI', but found '{0}' at line {1}, column {2}
valueCannotBeCastToSpecifiedType = The literal value '{0}' at line {1}, column {2} cannot be cast to a {3} type: {4}
noMatchingBracketFound = No matching closing bracket for the one at line {0}, column {1}
expectingLiteralAndUnableToParseAsLong = Expecting literal and unable to parse '{0}' at line {1}, column {2} as a long
expectingLiteralAndUnableToParseAsDouble = Expecting literal and unable to parse '{0}' at line {1}, column {2} as a double
expectingLiteralAndUnableToParseAsDate = Expecting literal and unable to parse '{0}' at line {1}, column {2} as a date
unexpectedClosingParenthesis = Unexpected closing parenthesis without a matching opening parenthesis
leftAndRightQueriesInSetQueryMustHaveUnionableColumns = The left and right queries in a set query must have unionable columns: {0} vs {1}
operatorIsNotValidAgainstColumnInTable = The '{0}' operator is not valid against the '{1}' column in the '{2}' table. Only these operators are allowed: {3}
columnInTableIsNotOrderable = The '{0}' column in the '{1}' table cannot be used in the ordering clause of a query.

# Search
interruptedWhileClosingChannel = Thread was interrupted while closing request processing channel for source "{0}"
errorWhilePerformingQuery = Error while performing the query "{0}" against the content in the "{1}" workspace of the "{2}" source: {3}
errorShuttingDownExecutorServiceInSearchEngineIndexer = Error shutting down the executor service in the search engine indexer for the search engine using the "{0}" source
searchEngineIndexerForSourceHasAlreadyBeenClosed = The search engine indexer for the "{0}" source has already been closed and cannot be used

# RepositoryConnectionPool
poolKeepAliveTimeDescription =  Timeout in seconds for idle connections waiting to be used. This timeout only when there are more connections than specified by the 'Core Pool Size'. Otherwise they wait forever to be used.
poolKeepAliveTimeLabel = Keep Alive Time
poolKeepAliveTimeCategory = 
poolCorePoolSizeDescription = The target number of connections that the pool will maintain. The number of connections in the pool will generally track close to this number, though fluctuations are always to be expected.
poolCorePoolSizeLabel = Core Pool Size
poolCorePoolSizeCategory = 
poolMaxiumumPoolSizeDescription = Maximum number of connections allowed in the pool. If the pool contains this number of connections, any returned connections will be closed.
poolMaxiumumPoolSizeLabel = Maximum Pool Size
poolMaxiumumPoolSizeCategory = 
poolValidateConnectionBeforeUseDescription = Flag specifying whether an unused connection should be validated before it is given out for use.
poolValidateConnectionBeforeUseLabel = Validate Connection Before Using
poolValidateConnectionBeforeUseCategory = 
poolPingTimeoutDescription = The default time in seconds that ping should wait before timing out and failing.
poolPingTimeoutLabel = Ping Timeout
poolPingTimeoutCategory = 
poolMaximumFailedAttemptsBeforeErrorDescription = The number of times an attempt to obtain a new connection should fail with invalid connections before failing.
poolMaximumFailedAttemptsBeforeErrorLabel = Maximum Failed Attempts Before Error
poolMaximumFailedAttemptsBeforeErrorCategory = 
